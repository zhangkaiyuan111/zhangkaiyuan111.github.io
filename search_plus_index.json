{"./":{"url":"./","title":"Introduction","keywords":"","body":" 计算机科学 文学 "},"computer/computer.html":{"url":"computer/computer.html","title":"计算机","keywords":"","body":" glibc linux "},"computer/glibc/glibc.html":{"url":"computer/glibc/glibc.html","title":"glibc","keywords":"","body":" 虚拟地址分配和分页 "},"computer/glibc/memoryManagement/memoryManagement.html":{"url":"computer/glibc/memoryManagement/memoryManagement.html","title":"1 虚拟地址分配和分页","keywords":"","body":" Memory management 进程内存概念(Process Memory Concepts) GNU 分配器(The GNU Allocator) 页表 gdb 调试 "},"computer/glibc/memoryManagement/ProcessMemoryConcepts.html":{"url":"computer/glibc/memoryManagement/ProcessMemoryConcepts.html","title":"1.1 进程内存概念","keywords":"","body":" 进程内存概念 进程可用的最基本资源之一是内存。系统组织内存的方式有很多种，但在典型的一种方式中，每个进程都有一个线性虚拟地址空间，地址从零到某个巨大的最大值。它不必是连续的；即，并非所有这些地址实际中都可用于存储数据。 虚拟内存被分成页（典型值为 4 KB）。支持虚拟内存的每一页的是实际内存的一页（称为帧）或一些辅助存储，通常是磁盘空间。磁盘空间可能是交换空间或只是一些普通的磁盘文件。实际上，一个全为零的页有时根本不存在一个标志说它是全零的。 实际内存或后备存储的同一帧可以支持属于多个进程的多个虚拟页。通常是这种情况，例如，GNU C 库代码占用的虚拟内存。包含 printf 函数的同一个实际内存帧支持每个在其程序中调用 printf 的现有进程中的虚拟内存页。 为了让程序访问虚拟页的任何部分，该页此时必须由实际帧支持或连接到实际帧。但是由于虚拟内存通常比实际内存多得多，因此页必须定期在实际内存和后备存储之间来回移动，当进程需要访问它们时进入实际内存，然后在不再需要时退回到后备存储。这种移动称为分页。 当一个程序试图访问一个当时没有实际内存支持的页时，这被称为页错误。当发生页错误时，内核暂停进程，将页放入实际页帧中（这称为“分页（paging in）”或“缺页中断（faulting in）”），然后恢复进程，以便从进程的角度来看，页一直在实际内存中。事实上，对于进程来说，所有页似乎总是在实际内存中。除了一件事：通常为几纳秒的指令的执行时间突然变得非常非常长（因为内核通常必须执行I/O才能完成换页（page-in））。对于对此敏感的程序，锁定页面中描述的功能可以控制它。 在每个虚拟地址空间内，一个进程必须跟踪哪些地址是什么，该进程称为内存分配。分配通常会让人想到分配稀缺资源，但在虚拟内存的情况下，这不是主要目标，因为它通常比任何人需要的要多得多。进程内的内存分配主要只是确保同一字节的内存不用于存储两个不同的东西。 进程以两种主要方式分配内存：通过 exec 和以编程方式。实际上，fork是第三种方式，但不是很有趣。请参阅创建进程。 Exec是为进程创建虚拟地址空间，将其基本程序加载到其中并执行程序的操作。它由“exec”函数族（例如 execl）完成。该操作获取一个程序文件（可执行文件），它分配空间以加载可执行文件中的所有数据，加载它并将控制权转移给它。该数据最值得注意的是程序的指令（文本），还有程序中的文字和常量，甚至一些变量：具有静态存储类的 C 变量（请参阅 C 程序中的内存分配）。 一旦该程序开始执行，它就会使用程序分配来获得额外的内存。在带有 GNU C 库的 C 程序中，有两种程序分配方式：自动分配和动态分配。请参阅 C 程序中的内存分配。 内存映射 I/O 是另一种形式的动态虚拟内存分配。将内存映射到文件意味着声明某个进程地址范围的内容应与指定的常规文件的内容相同。系统使虚拟内存最初包含文件的内容，如果您修改内存，系统会将相同的修改写入文件。请注意，由于虚拟内存和页错误的魔力，在程序访问虚拟内存之前，系统没有理由执行 I/O 来读取文件或为其内容分配实际内存。请参阅内存映射 I/O。 正如它以编程方式分配内存一样，程序可以以编程方式解除分配（释放）它。您无法释放 exec 分配的内存。当程序退出或执行时，你可能会说它的所有内存都被释放了，但是由于在这两种情况下地址空间都不存在了，这一点真的没有实际意义。请参阅程序终止。 "},"computer/glibc/memoryManagement/GNUAllocator.html":{"url":"computer/glibc/memoryManagement/GNUAllocator.html","title":"1.2 GNU 分配器","keywords":"","body":" GNU 分配器 GNU C 库中的 malloc 实现派生自 ptmalloc (pthreads malloc)，而后者又派生自 dlmalloc (由Doug Lea在1987年开发完成，这是Android系统中使用的内存分配器。而Linux系统中采用的是ptmalloc，ptmalloc在dlmalloc的基础上进行了改进，以更好适应多线程)。这个 malloc 可以根据它们的大小和可能由用户控制的某些参数以两种不同的方式分配内存。最常见的方法是从大的连续内存区域分配部分内存（称为块）并管理这些区域以优化它们的使用并减少不可用块形式的浪费。传统上，系统堆被设置为一个大内存区域，但 GNU C 库 malloc 实现维护多个这样的区域以优化它们在多线程应用程序中的使用。每个这样的区域在内部被称为一个arena。 与其他版本相反，GNU C 库中的 malloc 不会将块大小四舍五入为 2 的幂，无论是大的还是小的大小。相邻的块可以在空闲时合并，无论它们的大小是多少。这使得该实现适用于各种分配模式，而通常不会因碎片而导致大量内存浪费。多个 arena 的存在允许多个线程同时在单独的 arena 中分配内存，从而提高性能。 内存分配的另一种方式是非常大的块，即比页大得多。这些请求使用 mmap 分配（匿名或通过 /dev/zero；请参阅内存映射 I/O）。这具有很大的优势，即这些块在被释放时会立即返回到系统。因此，不会发生大块被“锁定”在较小块之间的情况，即使在调用 free 之后也会浪费内存。要使用的 mmap 的大小阈值是动态的，并根据程序的分配模式进行调整。mallopt 可用于使用 M_MMAP_THRESHOLD 静态调整阈值，并且可以使用 M_MMAP_MAX 完全禁用 mmap 的使用；请参阅 Malloc 可调参数。 GNU 分配器的更详细的技术描述保存在 GNU C 库 wiki 中。请参阅wiki。 可以使用您自己的自定义 malloc 代替 GNU C 库提供的内置分配器。请参阅替换 malloc。 基本内存分配（malloc） 要分配一块内存，请调用 malloc。此函数的原型位于 stdlib.h 中。 函数：void * malloc (size t size) 此函数返回一个指向新分配的块 size 字节长的指针，如果无法分配块，则返回一个空指针（设置 errno）。 块的内容是未定义的；您必须自己初始化它（或使用 calloc 代替；请参阅分配已清除空间）。 您可以将 malloc 的结果存储到任何指针变量中而无需强制转换，因为 ISO C 在必要时会自动将类型 void * 转换为另一种类型的指针。但是，如果需要类型但上下文未指定类型，则强制类型转换是必要的。请记住，在为字符串分配空间时，malloc 的参数必须是字符串长度加一。这是因为字符串以不计入字符串“长度”但需要空间的空字符终止。 请记住，在为字符串分配空间时，malloc 的参数必须是字符串长度加一。这是因为字符串以不计入字符串“长度”但需要空间的空字符终止。 malloc 为您提供的块保证是对齐的，以便它可以保存任何类型的数据。在 GNU 系统上，地址在 32 位系统上始终是 8 的倍数，在 64 位系统上始终是 16 的倍数。很少需要任何更高的边界（例如页面边界）；对于这些情况，请使用 aligned_alloc 或 posix_memalign（请参阅分配对齐的内存块）。 释放malloc分配的内存（free） 当您不再需要使用 malloc 获得的块时，请使用 free 函数使该块可再次分配。此函数的原型位于 stdlib.h 中 函数：void free (void *ptr) 有时，free 实际上可以将内存返回给操作系统，并使进程更小。通常，它所能做的就是允许稍后调用 malloc 来重用空间。同时，该空间作为 malloc 内部使用的空闲列表的一部分保留在您的程序中。 在程序结束时释放块没有意义，因为当进程终止时，程序的所有空间都归还给系统。 更改块的大小（realloc） 您可以通过调用 realloc 或 reallocarray 使块更长。这些函数在 stdlib.h 中声明。 函数：void realloc (void ptr, size t newsize) realloc 函数将地址为 ptr 的块的大小更改为 newsize。由于块末尾之后的空间可能正在使用中，realloc 可能会发现有必要将块复制到有更多可用空间的新地址。realloc 的返回值是块的新地址。如果需要移动块，realloc 会复制旧的内容。 如果你为 ptr 传递一个空指针，realloc 的行为就像’malloc (newsize)'。否则，如果 newsize 为零，realloc 释放块并返回 NULL。否则，如果 realloc 无法重新分配请求的大小，则返回 NULL 并设置 errno；原始块不受干扰。 函数：void reallocarray (void ptr, size t nmemb, size t size) reallocarray 函数将地址为 ptr 的块的大小更改为足够长以包含 nmemb 元素的向量（vector），每个元素的大小为size。它等效于“realloc (ptr, nmemb * size)”，但如果乘法溢出，reallocarray 会安全失败，方法是将 errno 设置为 ENOMEM，返回一个空指针，并保持原始块不变。 当分配块的新大小是可能溢出的乘法结果时，应使用 reallocarray 而不是 realloc。 与 malloc 一样，如果没有可用的内存空间使块变大，realloc 和 reallocarray 可能会返回空指针。发生这种情况时，原始块保持不变；它没有被修改或搬移。 您还可以使用 realloc 或 reallocarray 使块更小。这样做的原因是为了避免在只需要一点内存空间时占用大量内存空间。在几种分配实现中，有时需要复制一个块，因此如果没有其他可用空间，它可能会失败。 分配已清理空间（calloc） 函数 calloc 分配内存并将其清除为零。它在 stdlib.h 中声明。 函数：void * calloc (size t count, size t eltsize) 此函数分配一个足够长的块以包含 count 元素的向量，每个元素的大小为 eltsize。在 calloc 返回之前，它的内容被清零。 分配对齐的内存块（aligned_alloc） 在 GNU 系统中 malloc 或 realloc 返回的块的地址始终是 8 的倍数（或 64 位系统上的 16）。如果您需要一个地址是 2 的高次幂的倍数的块，请使用aligned_alloc或posix_memalign。aligned_alloc 和 posix_memalign 在 stdlib.h 中声明。 函数：void * aligned_alloc (size t alignment, size t size) aligned_alloc 函数分配一个size字节的块，其地址是alignment的倍数。alignment必须是 2 的幂，size必须是alignment的倍数。aligned_alloc 函数在出错时返回一个空指针，并将 errno 设置为下列值之一： ENOMEM 没有足够的内存来满足请求。 EINVAL alignment不是 2 的幂。 malloc可调参数（mallopt） 函数：int mallopt (int param, int value)，param 参数指定要设置的参数，value 是要设置的新值。 MMMAP_MAX：使用 mmap 分配的最大块数。将此设置为零将禁用所有 mmap 的使用，该参数的默认值为 65536，通过将环境变量 MALLOC_MMAP_MAX 设置为所需的值，也可以在启动时为进程设置此参数。 MMMAP_THRESHOLD：使用 mmap 系统调用将所有大于此值的块分配到正常堆之外。这样可以保证这些块的内存 free 后可以返回给系统。请注意，小于此阈值的请求仍可能通过 mmap 分配，如果未设置此参数，则默认值设置为 128 KiB，并动态调整阈值以适应程序的分配模式。如果设置了参数，则禁用动态调整，并将值静态设置为输入值，通过将环境变量 MALLOC_MMAP_THRESHOLD 设置为所需的值，也可以在启动时为进程设置此参数。 MPERTURB：如果非零，则在分配内存块（由 calloc 分配时除外）和释放时，根据此参数的某些低位的位填充内存块。这可用于调试未初始化或已释放堆内存的使用。请注意，此选项不保证释放的块将具有任何特定值。它只保证块被释放之前的内容将被覆盖，此参数的默认值为 0，通过将环境变量 MALLOC_PERTURB 设置为所需的值，也可以在启动时为进程设置此参数。 MTOP_PAD：此参数确定当需要扩展 arena 时从系统获得的额外内存量。它还指定缩小 arena 时要保留的字节数。这提供了堆大小的必要滞后，从而可以避免过多的系统调用，此参数的默认值为 0，通过将环境变量 MALLOC_TOP_PAD 设置为所需的值，也可以在启动时为进程设置此参数。 MTRIM_THRESHOLD：这是最顶层的可释放块的最小大小（以字节为单位），它将触发系统调用以将内存返回给系统。如果未设置此参数，则默认值设置为 128 KiB，并动态调整阈值以适应程序的分配模式。如果设置了参数，则禁用动态调整，并将值静态设置为提供的输入，通过将环境变量 MALLOC_TRIM_THRESHOLD 设置为所需的值，也可以在启动时为进程设置此参数。 M_ARENA_TEST：该参数指定在对 arena 数量限制进行测试之前可以创建的 arena 数量。如果设置了 M_ARENA_MAX，则忽略该值。此参数的默认值在 32 位系统上为 2，在 64 位系统上为 8。通过将环境变量 MALLOC_ARENA_TEST 设置为所需的值，也可以在启动时为进程设置此参数。 M_ARENA_MAX：此参数设置要使用的 arena 数量，而与系统中的核心数量无关，此可调参数的默认值为 0，这意味着对 arenas 数量的限制由在线 CPU 内核数决定。对于 32 位系统，限制是在线内核数的两倍，在 64 位系统上，它是八倍的核心在线数量。请注意，默认值并非源自 M_ARENA_TEST 的默认值，而是独立计算的，通过将环境变量 MALLOC_ARENA_MAX 设置为所需的值，也可以在启动时为进程设置此参数。 堆一致性检查（mcheck） 您可以使用 mcheck 函数要求 malloc 检查动态内存的一致性，并使用 LD_PRELOAD 环境变量预加载 malloc 调试库 libc_malloc_debug。这个函数是一个 GNU 扩展，在 mcheck.h 中声明。 函数：int mcheck (void (*abortfn) (enum mcheck_status status)) 调用 mcheck 告诉 malloc 执行偶尔的（occasional）一致性检查。这些将捕获诸如写入超过使用 malloc 分配的块的末尾之类的东西。abortfn 参数是发现不一致时调用的函数。如果您提供一个空指针，则 mcheck 使用一个默认函数，该函数打印一条消息并调用 abort（请参阅终止程序）。您提供的函数使用一个参数调用，该参数说明检测到哪种不一致；其类型如下所述。 一旦你用 malloc 分配了任何东西，再开始分配检查为时已晚。所以 mcheck 在这种情况下什么都不做。如果调用太晚，该函数返回 -1，否则返回 0（成功时）。 安排尽早调用 mcheck 的最简单方法是在链接程序时使用选项“-lmcheck”；那么你根本不需要修改你的程序源。或者，您可以使用调试器在程序启动时插入对 mcheck 的调用，例如，这些 gdb 命令将在程序启动时自动调用 mcheck： (gdb) break main Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10 (gdb) command 1 Type commands for when breakpoint 1 is hit, one per line. End with a line saying just \"end\". >call mcheck(0) >continue >end (gdb) ... 函数：enum mcheck_status mprobe (void *pointer) mprobe 函数允许您显式检查特定分配块中的不一致。您必须已经在程序开始时调用了 mcheck 来进行偶尔的检查；调用 mprobe 请求在调用时进行额外的一致性检查。 参数 pointer 必须是 malloc 或 realloc 返回的指针。mprobe 返回一个值，说明发现了什么不一致（如果有）。数据类型：enum mcheck_status，这些值如下所述。 MCHECK_DISABLED：在第一次分配之前没有调用 mcheck。无法进行一致性检查。 MCHECK_OK：未检测到不一致。 MCHECK_HEAD：块之前的数据被立即修改。这通常发生在数组索引或指针减少太多时。 MCHECK_TAIL：块之后的数据被立即修改。当数组索引或指针增加太多时，通常会发生这种情况。 MCHECK_FREE：该块已被释放。 在使用 malloc、realloc 和 free 时检查和防止错误的另一种可能性是设置环境变量 MALLOCCHECK。当 MALLOCCHECK 设置为小于 4 的非零值时，将使用一种特殊的（效率较低的）实现，该实现旨在容忍简单的错误，例如使用相同参数的两次 free 调用，或单个字节的溢出（一个错误）。然而，并非所有此类错误都可以得到保护，并且可能导致内存泄漏。与 mcheck 的情况一样，需要预加载 libcmalloc_debug 库以启用 MALLOC_CHECK 功能。如果没有这个预加载的库，设置 MALLOCCHECK 将无效。MALLOCCHECK 存在一个问题：在 SUID 或 SGID 二进制文件中，由于与正常程序行为不同，它可能被利用，或者它现在向标准错误描述符写入一些内容。因此，对于 SUID 和 SGID 二进制文件，默认情况下禁用 MALLOCCHECK 的使用。系统管理员可以通过添加文件 /etc/suid-debug 再次启用它（内容不重要，可以为空）。 使用 MALLOCCHECK 和使用“-lmcheck”链接有什么区别呢？ MALLOCCHECK 与“-lmcheck”正交。添加了“-lmcheck”以实现向后兼容性。MALLOCCHECK 和“-lmcheck”都应该发现相同的错误——但是使用 MALLOCCHECK 你不需要重新编译你的应用程序 任何检测到的堆损坏都会导致进程立即终止。 统计使用malloc分配的内存信息（mallinfo2） 您可以通过调用 mallinfo2 函数获取有关动态内存分配的信息。此函数及其相关数据类型在 malloc.h 中声明；它们是标准 SVID/XPG 版本的扩展。 数据类型：struct mallinfo2 size_t arena 这是 malloc 用 sbrk 分配的内存的总大小，以字节为单位。 size_t ordblks 这是未使用的块数。 内存分配器大小从操作系统内部获取内存块，然后将它们分割以满足各个 malloc 请求。 size_t smblks 该字段未使用。 size_t hblks 这是使用 mmap 分配的块的总数。 size_t hblkhd 这是使用 mmap 分配的内存的总大小，以字节为单位。 size_t usmblks 该字段未使用且始终为 0。 size_t fsmblks 该字段未使用。 size_t uordblks 这是 malloc 分配的块所占用的内存总大小。 size_t fordblks 这是空闲（未使用）块占用的内存总大小。 size_t keepcost 这是通常与堆末端接壤的最高可释放块的大小（即虚拟地址空间数据段的高端）。 函数：struct mallinfo2 mallinfo2 (void) 此函数以 struct mallinfo2 类型的结构返回有关当前动态内存使用情况的信息。 malloc相关函数总结 ``` void *malloc (size_t size) 分配一个 size 字节的块。 void free (void *addr) 释放之前由 malloc 分配的块。 void *realloc (void *addr, size_t size) 使以前由 malloc 分配的块更大或更小，可能通过将其复制到新位置。 void *reallocarray (void *ptr, size_t nmemb, size_t size) 将 malloc 先前分配的块的大小更改为 nmemb * size 个字节，与 realloc 一样。 void *calloc (size_t count, size_t eltsize) 使用 malloc 分配一个 count * eltsize 字节块，并将其内容设置为零。 void *valloc (size_t size) 从页边界开始分配大小字节块。 void *aligned_alloc (size_t size, size_t alignment) 从 alignment 倍数的地址开始分配 size 字节块。 int posix_memalign (void **memptr, size_t alignment, size_t size) 从 alignment 倍数的地址开始分配 size 字节块。 void *memalign (size_t size, size_t boundary) 分配一个 size 字节的块，从一个 boundary 倍数的地址开始。 int mallopt (int param, int value) 调整可调参数。 int mcheck (void (*abortfn) (void)) 告诉 malloc 对动态分配的内存执行偶尔的一致性检查，并在发现不一致时调用 abortfn。 struct mallinfo2 mallinfo2 (void) 返回有关当前动态内存使用情况的信息。 ``` 分配调试 基于不使用垃圾回收动态内存分配的语言进行编程时，一项复杂的任务是查找内存泄漏。长时间运行的程序必须确保动态分配的对象在其生命周期结束时被释放。如果这没有发生，系统迟早会耗尽内存，GNU C 库中的 malloc 实现提供了一些简单的方法来检测此类泄漏并获取一些信息以找到位置。为此，应用程序必须以由环境变量启用的特殊模式启动。如果未启用调试模式，则程序不会受到速度损失。 函数：void mtrace (void) mtrace 函数提供了一种方法来跟踪调用它的程序中的内存分配事件。它在库中默认禁用，可以通过使用 LD_PRELOAD 环境变量预加载调试库 libc_malloc_debug 来启用。 当调用 mtrace 函数时，它会查找名为 MALLOC_TRACE 的环境变量。这个变量应该包含一个有效的文件名。用户必须具有写入权限。如果文件已存在，则将其截断。如果没有设置环境变量或者它没有命名一个可以打开写入的有效文件，则什么也不做。malloc 等的行为没有改变。出于显而易见的原因，如果应用程序安装时设置了 SUID 或 SGID 位，也会发生这种情况。 如果命名文件成功打开，mtrace 会为函数 malloc、realloc 和 free 安装特殊处理程序。从那时起，这些函数的所有使用都被跟踪并协议化到文件中。当然，现在对跟踪函数的所有调用都会有速度损失，因此在正常使用期间不应启用跟踪。 函数：void muntrace (void) 在使用 mtrace 启用跟踪 malloc 调用后，可以调用 muntrace 函数。如果没有（成功）调用 mtrace，则 muntrace 什么也不做。否则，它会卸载 malloc、realloc 和 free 的处理程序，然后关闭协议文件。不再有调用被协议处理，程序再次全速运行。此功能是 GNU 扩展，通常在其他系统上不可用。原型可以在 mcheck.h 中找到。 即使跟踪功能不会影响程序的运行时行为，在所有程序中调用 mtrace 也不是一个好主意。试想一下，您使用 mtrace 调试程序，并且调试会话中使用的所有其他程序也跟踪它们的 malloc 调用。所有程序的输出文件都相同，因此无法使用。因此，只有在为调试而编译时才应该调用 mtrace。因此，程序可以像这样开始： #include int main (int argc, char *argv[]) { #ifdef DEBUGGING mtrace (); #endif ... } 如果您想在程序的整个运行时跟踪调用，这就是您所需要的。或者，您可以随时调用 muntrace 来停止跟踪。甚至可以通过对 mtrace 的新调用再次重新启动跟踪。但这可能会导致不可靠的结果，因为可能会调用未调用的函数。请注意，不仅应用程序使用跟踪函数，库（包括 C 库本身）也使用这些函数。 最后一点也是为什么在程序终止之前调用 muntrace 不是一个好主意的原因。库仅在程序从 main 返回或调用 exit 后才被通知程序终止，因此在此之前无法释放它们使用的内存。所以最好的办法是调用 mtrace 作为程序中的第一个函数，并且永远不要调用 muntrace。因此，该程序跟踪几乎所有 malloc 函数的使用（除了那些由程序的构造函数或使用的库执行的调用）。 解释跟踪 GNU C 库附带的一个程序，它可以解释跟踪并以用户友好的方式输出摘要。该程序称为 mtrace（它实际上是一个 Perl 脚本），它接受一两个参数。在任何情况下，必须指定带有跟踪输出的文件的名称。如果可选参数位于跟踪文件的名称之前，则它必须是生成跟踪的程序的名称。 zhangkaiyuan@ubuntu:$ mtrace tst-mtrace log No memory leaks. 在这种情况下，程序 tst-mtrace 运行并生成了一个跟踪文件日志。mtrace 打印的消息显示代码没有问题，所有分配的内存随后都被释放。 如果我们在上面给出的示例跟踪上调用 mtrace，我们会得到不同的输出： zhangkaiyuan@ubuntu:$ mtrace tst errlog - 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39 - 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39 - 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39 Memory not freed: ----------------- Address Size Caller 0x08064c48 0x14 at /home/drepper/tst.c:33 0x08064c60 0x14 at /home/drepper/tst.c:33 0x08064c78 0x14 at /home/drepper/tst.c:33 0x08064c90 0x14 at /home/drepper/tst.c:33 解释这个输出并不复杂。最多检测两种不同的情况。首先，free 被调用用于从未被分配函数返回的指针。这通常是一个非常糟糕的问题，输出的前三行显示了它的样子。像这样的情况非常罕见，如果它们出现，它们会非常剧烈地出现：程序通常会崩溃。 替换malloc GNU C 库支持用具有相同接口的不同分配器替换内置 malloc 实现。对于动态链接的程序，这通过 ELF 符号插入发生，或者使用共享对象依赖关系或 LD_PRELOAD。对于静态链接，必须先链接 m​​alloc 替换库，然后再链接 libc.a（显式或隐式）。未能提供完整的替换函数集（即应用程序、GNU C 库和其他链接库使用的所有函数）可能导致静态链接失败，并在运行时导致堆损坏和应用程序崩溃。替换函数应该实现它们在 GNU C 库中对应的行为；例如，替换free 也应该保留errno。下表给出了自定义 malloc 必须提供的最小功能集。GNU C 库需要这些与 malloc 相关的函数才能工作。 malloc free calloc realloc GNU C 库中的 malloc 实现提供了库本身不使用的附加功能，但其他系统库和应用程序经常使用这些功能。通用替代 malloc 实现也应该提供这些函数的定义。它们的名称列在下表中。 aligned_alloc malloc_usable_size memalign posix_memalign pvalloc valloc 其他与 malloc 相关的函数（例如 mallopt 或 mallinfo2）在使用替换 malloc 时不会产生任何影响或返回不正确的统计信息。但是，未能替换这些函数通常不会导致崩溃或其他不正确的应用程序行为，但可能会导致静态链接失败。GNU C 库中还有其他函数（reallocarray、strdup 等）未在上面列出，但会将新分配的内存返回给调用者。不支持替换这些函数，并且可能会产生不正确的结果。这些函数的 GNU C 库实现在可用时调用替换分配器函数，因此它们可以与 malloc 替换一起正常工作。 参考 glibc手册03：虚拟地址分配和分页 Virtual Memory Allocation And Paging "},"computer/glibc/memoryManagement/pageTable.html":{"url":"computer/glibc/memoryManagement/pageTable.html","title":"1.3 页表","keywords":"","body":" 页表 引出页目录 对于32位虚拟地址空间，假设页面大小为4K，页表项大小为4字节：一个进程有 4G/4K = 2^20个页面，因为一个页面需要一个页表项来对应，所以，进程的页表项个数也为2^20个，不难得出该进程的页表占用了 2^20 * 4 / 4K = 1024个页面的大小，对于64位的虚拟地址空间来讲，页表规模更大，理论值32000TB，其实，页表页就是存放进程页表的页面，他属于进程的一部分，页表也是以页为基本存储单位的。所以，为了内存的高效使用，一般都不会将这么大规模的页表页存放在连续的内存上，所以，我们引入了页表页的地址索引表，页目录。提供一个目录，这样就变成了一个二维的结构，甚至现在很多计算机有多维的页表结构，也叫多级页表。 以两级页表为例。一级页表中的每个 PTE（page table entry）映射虚拟地址空间的一个 4MB 的片（chunck），每一片由 1024 个连续的页面组成。一级 PTE 指向二级页表的基址。这样 32 位地址空间使用 1024 个一级 PTE 就可以表示。需要的二级页表总条目还是 2^32 / 2^12 = 2^20 个。这里的关键在于如果一级 PTE i 中的页面都未被分配，一级 PTE 就为空。多级页表减少内存占用的关键在于： 如果一级页表中的一个 PTE 为空，那么相应的二级页表就根本不会存在。这是一种巨大的潜在节约。 只有一级页表才需要常驻内存。虚拟内存系统可以在需要时创建、页面调入或者调出二级页表，从而减轻内存的压力。 第二个问题是页表是在内存中，而 MMU 位于 CPU 芯片中，这样每次地址翻译可能都需要先访问一次内存中的页表（CPU L1,L2,L3 Cache Miss 的时候访问内存），效率非常低下。对应的解决方案是引入页表的高速缓存：TLB（Translation Lookaside Buffer）。 ARM中的分页 ARMv7架构支持三种页大小：1MB，64KB和4KB，以4KB页大小，二级页表为例，32bit虚拟地址被划分为3部分： L1 Table Index[31:20]：最高12bit；用于索引一级页表，可索引 2^12=4k 项一级页表 L2 Table Index[19:12]：中间8bit；结合一级页表表项索引二级页表，可索引 2^(12+8) 项二级页表 Page Index[11:0]：最低12bit。结合二级页表表项address[31:12]索引物理地址 地址转换过程，TTBR寄存器Translation base[31:14]和虚拟地址的L1 Table Index[31:20]索引到一级页表物理地址，一级页表Page table base address[31:10]和虚拟地址L2 Table Index[19:12]索引到二级页表物理地址，二级页表Small page base address[31:12]和虚拟地址的Page Index[11:0]索引到物理地址。 ARMv7 4KB Paging页表长啥样 ARMv7 4KB分页机制采用二级页表管理。 一级页表属性见下图： Page table base address[31:10]：线性地址转换二级页表物理地址，用于配合线性地址Page Table找到二级页表物理地址； NS[3]：Non-secure，非安全模式下忽略； Domain[8:5]:域，内存区域的集合，可以定义16个域，划分其访问权限，超越域访问权限时会触发Permission fault。 二级页表属性见下图： Small page base address[31:12]：线性地址转换物理地址，用于配合线性地址offset找到物理地址； XN[0]：Execute-never； C,B[3:2]：定义内部cache属性。 TEX[8:6]：定义外部cache属性。 S[10]：Shareable； nG[11]：not global，指定页表是否是全局的，用于TLB； ARM架构提供了两个页表基址寄存器TTBR0和TTBR1，可以分别用于用户态和内核态。 Kernel中的分页 Linux Kernel分页为了支持不同的CPU体系架构，设计了五级分页模型，如下图所示。五级分页模型是为了兼容X86-64体系架构中的5-Level Paging分页模式 五级分页每级命名分别为页全局目录(PGD)、页4级目录(P4D)、页上级目录(PUD)、页中间目录(PMD)、页表(PTE)。对应的相关宏定义命名如下：#define PGDIR_SHIFT #define P4D_SHIFT #define PUD_SHIFT #define PMD_SHIFT #define PAGE_SHIFT Linux对于页表的操作主要定义了以下函数或宏。这些操作方法也是与体系架构相关的，因此需要按照体系架构的硬件定义去实现。 pgd_offset(mm, addr) 根据入参内存描述符mm和虚拟地址address，找到address在页全局目录中相应表项的线性地址。 pgd_offset_k(addr) 根据入参虚拟地址address和init_mm，找到address在页全局目录中相应表项的线性地址。仅用于内核页表。 p4d_offset(pgd, addr) 根据入参pgd和虚拟地址address，找到address在页四级目录中相应表项的线性地址。 pud_offset(p4d,addr) 根据入参p4d和虚拟地址address，找到address在页上级目录中相应表项的线性地址。 pmd_offset(pud, address) 根据入参pud和虚拟地址address，找到address在页中间目录中相应表项的线性地址。 pte_index(address) 根据入参虚拟地址address，找到address在页表中索引。 set_pgd(pgdp, pgd) 向PGD写入指定的值 set_p4d(p4dp, p4d) 向P4D写入指定的值 ARMv7分页 ARMv7作为32bit CPU架构，其分页一般采用两级分页。第一级为页目录(PGD)，第二级为页映射表(PTE)，页大小为4KB。如下图所示为ARMv7页表映射示意图，与ARMv7硬件4KB分页机制相对应。页表基址寄存器TTBRx(x为0或1)。 TTBRx（Translation Table Base Register x）即页表转换基址寄存器，ARMv7提供了TTBR0和TTBR1两个寄存器，Linux分别将其应用于内核态和用户态。进程地址空间切换实质就是将TTBR0寄存器中Translation Table Base 0 Address修改为当前进程的PGD（页全局目录）。一级页表数量为4096，二级页表数量为256。 分段 分页内存管理，可以说通过多级页表，TLB 等，分页内存管理方法已经相当不错了。那么分页有什么缺点呢？ 共享困难：通过共享页面来实现共享当然是可以的。这里的问题在于我们要保证页面上只包含可以共享的内容并不是一件容易的事儿，因为进程空间是直接映射到页面上的。这样一个页面上很可能包含不能共享的内容（比如既包含代码又包含数据，代码可以共享，而数据不能共享）。早期的 PDP-11 实现的一种解决方法是为指令和数据设置分离的地址空间，分别称为 I 空间和 D 空间（其实这已经和分段很像了）。 程序地址空间受限于虚拟地址：我们将程序全部映射到一个统一的虚拟地址的问题在于不好扩张。不如我们程序的地址按先代码放在一起，然后把数据放在一起，然后再放 XXX，这样其中某一部分的空间扩张起来都会影响到相邻的空间，非常不方便。 上面的问题一个比较直观的解决方法是提供多个独立的地址空间，也就是段（segment）。每个段的长度视具体的段不同而不同，而且是可以在运行期动态改变的。因为每个段都构成了一个独立的地址空间，所以它们可以独立的增长或者减小而不会影响到其他的段。如果一个段比较大，把它整个保存到内存中可能很不方便甚至是不可能的，因此可以对段采用分页管理，只有那些真正需要的页面才会被调入内存。 采用分段和分页结合的方式管理内存，一个地址由两个部分组成：段和段内地址。段内地址又进一步分为页号和页偏移。在进行内存访问时，过程如下： 根据段号找到段描述符（存放段基址）。 检查该段的页表是否在内存中。如果在，则找到它的位置，如果不在，则产生段错误。 检查所请求的虚拟页面的页表项，如果该页面不在内存中则产生缺页中断，如果在内存中就从页表项中取出这个页面在内存中的起始地址 将页面起始地址和偏移量进行拼接得到物理地址，然后完成读写。 每个 Linux 程序都有一个运行时内存映像，也就是各个段的布局，简单如下图所示。 "},"computer/glibc/memoryManagement/gdbDebug.html":{"url":"computer/glibc/memoryManagement/gdbDebug.html","title":"1.4 gdb调试","keywords":"","body":" GDB 调试 GDB 环境设置 进入gdbx@ubuntu:~/work/libs/libraries$ gdb ./output/build/app/glibc/tmem 设置调试源代码路径(gdb) directory package/glibc-2.37/malloc/ 显示调试源代码路径(gdb) show directoriesSource directories searched: /home/x/work/libs/libraries/package/glibc-2.37/malloc:$cdir:$cwd 设置断点(gdb) b main run 运行(gdb) r Step Into 单步跟踪进入，n(Step Over，单步跟踪)(gdb) s 使用 GDB 查看内存映射信息 (gdb) i proc mapping process 587676 Mapped address spaces: Start Addr End Addr Size Offset objfile 0x555555554000 0x555555555000 0x1000 0x0 /home/x/work/libs/libraries/output/build/app/glibc/tmem 0x555555555000 0x555555556000 0x1000 0x1000 /home/x/work/libs/libraries/output/build/app/glibc/tmem 0x555555556000 0x555555557000 0x1000 0x2000 /home/x/work/libs/libraries/output/build/app/glibc/tmem 0x555555557000 0x555555558000 0x1000 0x2000 /home/x/work/libs/libraries/output/build/app/glibc/tmem 0x555555558000 0x555555559000 0x1000 0x3000 /home/x/work/libs/libraries/output/build/app/glibc/tmem 0x7ffff7df2000 0x7ffff7df4000 0x2000 0x0 0x7ffff7df4000 0x7ffff7e1c000 0x28000 0x0 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7e1c000 0x7ffff7f57000 0x13b000 0x28000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7f57000 0x7ffff7fad000 0x56000 0x163000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fad000 0x7ffff7fae000 0x1000 0x1b9000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fae000 0x7ffff7fb2000 0x4000 0x1b9000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fb2000 0x7ffff7fb4000 0x2000 0x1bd000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fb4000 0x7ffff7fc3000 0xf000 0x0 0x7ffff7fc3000 0x7ffff7fc7000 0x4000 0x0 [vvar] 0x7ffff7fc7000 0x7ffff7fc9000 0x2000 0x0 [vdso] 0x7ffff7fc9000 0x7ffff7fca000 0x1000 0x0 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7fca000 0x7ffff7fef000 0x25000 0x1000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7fef000 0x7ffff7ffa000 0xb000 0x26000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7ffb000 0x7ffff7ffd000 0x2000 0x31000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7ffd000 0x7ffff7fff000 0x2000 0x33000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffffffde000 0x7ffffffff000 0x21000 0x0 [stack] 0xffffffffff600000 0xffffffffff601000 0x1000 0x0 [vsyscall] (gdb) 使用 GDB 查看程序的栈空间 bt(backtrace) 命令：查看函数调用的顺序，即当前函数向上的所有函数调用栈信息。 info frame 命令：与 bt 命令不同，i frame 命令查看当前函数调用的栈帧信息。而不是所有函数调用堆栈信息。 #include #include static void t() { char* p2 = malloc(32); snprintf(p2, 32, \"hello, I am here 2\"); } int main(int argc, char **argv) { char* p1 = malloc(32); snprintf(p1, 32, \"hello, I am here 1\"); printf(\"111111111111\\n\"); t(); return 0; } 测试程序如上： (gdb) b main Note: breakpoint 1 also set at pc 0x5555555551c3. Breakpoint 2 at 0x5555555551c3: file /home/x/work/libs/libraries/app/glibc/t_mem.c, line 9. (gdb) r Starting program: /home/x/work/libs/libraries/output/build/app/glibc/tmem Breakpoint 1, main (argc=32767, argv=0xcffffe358) at /home/x/work/libs/libraries/app/glibc/t_mem.c:9 9 char* p1 = malloc(32); (gdb) s 10 snprintf(p1, 32, \"hello, I am here 1\"); (gdb) __GI___libc_malloc (bytes=32) at malloc.c:3263 3263 { (gdb) bt #0 __GI___libc_malloc (bytes=32) at malloc.c:3263 #1 0x00005555555551e0 in main (argc=1, argv=0x7fffffffe238) at /home/x/work/libs/libraries/app/glibc/t_mem.c:10 (gdb) i frame Stack level 0, frame at 0x7fffffffe120: rip = 0x7ffff7e82b6e in __GI___libc_malloc (malloc.c:3263); saved rip = 0x5555555551e0 called by frame at 0x7fffffffe150 source language c. Arglist at 0x7fffffffe110, args: bytes=32 Locals at 0x7fffffffe110, Previous frame's sp is 0x7fffffffe120 Saved registers: rip at 0x7fffffffe118 (gdb) "},"computer/linux/linux.html":{"url":"computer/linux/linux.html","title":"linux","keywords":"","body":" elf文件详解 动态库 "},"computer/linux/elfFile.html":{"url":"computer/linux/elfFile.html","title":"1 elf文件详解","keywords":"","body":" elf 文件详解 对象文件(Object files)分类 可重定位文件(Relocatable File)这是由汇编器汇编生成的 .o 文件。后面的链接器(link editor)拿一个或一些 Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。我们可以使用 ar 工具将众多的 .o Relocatable object files 归档(archive)成 .a 静态库文件。如何产生 Relocatable file，你应该很熟悉了，请参见我们相关的基本概念文章和JulWiki。另外，可以预先告诉大家的是我们的内核可加载模块 .ko 文件也是 Relocatable object file。 可执行文件(Executable File)包含适合于执行的一个程序，此文件规定了exec() 如何创建一个程序的进程映像。这我们见的多了。文本编辑器vi、调式用的工具gdb、播放mp3歌曲的软件mplayer等等都是Executable object file。你应该已经知道，在我们的 Linux 系统里面，存在两种可执行的东西。除了这里说的 Executable object file，另外一种就是可执行的脚本(如shell脚本)。注意这些脚本不是 Executable object file，它们只是文本文件，但是执行这些脚本所用的解释器就是 Executable object file，比如 bash shell 程序。 共享目标文件(Shared Object File) *.so包含可在两种上下文中链接的代码和数据。动态库在发挥作用的过程中，必须经过两个步骤： 链接编辑器(link editor)拿它和其他Relocatable object file以及其他shared object file作为输入，经链接处理后，生成另外的 shared object file 或者 executable file。 在运行时，动态链接器(dynamic linker)拿它和一个Executable file以及另外一些 Shared object file 来一起处理，在Linux系统里面创建一个进程映像。 我们可以使用 file 命令来查看一个文件属于上面三类中的哪一种 x@ubuntu:~/work/libs/libraries$ file output/build/app/glibc/tmem output/build/app/glibc/tmem: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2, BuildID[sha1]=2d34a5877d15405a548f8e55b8f410748fde3084, for GNU/Linux 3.2.0, with debug_info, not stripped 格式说明 ELF头部 x@ubuntu:~/work/libs/libraries$ readelf -h output/build/app/glibc/tmem ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x10a0 Start of program headers: 64 (bytes into file) Start of section headers: 17904 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 13 Size of section headers: 64 (bytes) Number of section headers: 37 Section header string table index: 36 /* ELF Header */ #define EI_NIDENT 16 typedef struct elfhdr { unsigned char e_ident[EI_NIDENT]; /* ELF Identification */ Elf32_Half e_type; /* object file type */ Elf32_Half e_machine; /* machine */ Elf32_Word e_version; /* object file version */ Elf32_Addr e_entry; /* virtual entry point */ Elf32_Off e_phoff; /* program header table offset */ Elf32_Off e_shoff; /* section header table offset */ Elf32_Word e_flags; /* processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size */ Elf32_Half e_phentsize; /* program header entry size */ Elf32_Half e_phnum; /* number of program header entries */ Elf32_Half e_shentsize; /* section header entry size */ Elf32_Half e_shnum; /* number of section header entries */ Elf32_Half e_shstrndx; /* section header table's \"section header string table\" entry offset */ } Elf32_Ehdr; typedef struct { unsigned char e_ident[EI_NIDENT]; /* Id bytes */ Elf64_Quarter e_type; /* file type */ Elf64_Quarter e_machine; /* machine type */ Elf64_Half e_version; /* version number */ Elf64_Addr e_entry; /* entry point */ Elf64_Off e_phoff; /* Program hdr offset */ Elf64_Off e_shoff; /* Section hdr offset */ Elf64_Half e_flags; /* Processor flags */ Elf64_Quarter e_ehsize; /* sizeof ehdr */ Elf64_Quarter e_phentsize; /* Program header entry size */ Elf64_Quarter e_phnum; /* Number of program headers */ Elf64_Quarter e_shentsize; /* Section header entry size */ Elf64_Quarter e_shnum; /* Number of section headers */ Elf64_Quarter e_shstrndx; /* String table index */ } Elf64_Ehdr; 程序头部（Program Header） x@ubuntu:~/work/libs/libraries$ readelf -l output/build/app/glibc/tmem Elf file type is DYN (Shared object file) Entry point 0x10a0 There are 13 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000002e 0x000000000000002e R 0x1 [Requesting program interpreter: /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000818 0x0000000000000818 R 0x1000 LOAD 0x0000000000001000 0x0000000000001000 0x0000000000001000 0x00000000000002a5 0x00000000000002a5 R E 0x1000 LOAD 0x0000000000002000 0x0000000000002000 0x0000000000002000 0x00000000000001b0 0x00000000000001b0 R 0x1000 LOAD 0x0000000000002d98 0x0000000000003d98 0x0000000000003d98 0x0000000000000278 0x0000000000000280 RW 0x1000 DYNAMIC 0x0000000000002da8 0x0000000000003da8 0x0000000000003da8 0x0000000000000200 0x0000000000000200 RW 0x8 NOTE 0x0000000000000348 0x0000000000000348 0x0000000000000348 0x0000000000000020 0x0000000000000020 R 0x8 NOTE 0x0000000000000368 0x0000000000000368 0x0000000000000368 0x0000000000000044 0x0000000000000044 R 0x4 GNU_PROPERTY 0x0000000000000348 0x0000000000000348 0x0000000000000348 0x0000000000000020 0x0000000000000020 R 0x8 GNU_EH_FRAME 0x0000000000002038 0x0000000000002038 0x0000000000002038 0x000000000000004c 0x000000000000004c R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000002d98 0x0000000000003d98 0x0000000000003d98 0x0000000000000268 0x0000000000000268 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .plt.got .plt.sec .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .dynamic .got 可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段 或者系统准备程序执行所必需的其它信息。目标文件的“段”包含一个或者多个“节区”， 也就是“段内容(Segment Contents)”。程序头部仅对于可执行文件和共享目标文件 有意义。 可执行目标文件在 ELF 头部的 e_phentsize和e_phnum 成员中给出其自身程序头部 的大小。程序头部的数据结构: /* Program Header */ typedef struct { Elf32_Word p_type; /* segment type */ Elf32_Off p_offset; /* segment offset */ Elf32_Addr p_vaddr; /* virtual address of segment */ Elf32_Addr p_paddr; /* physical address - ignored? */ Elf32_Word p_filesz; /* number of bytes in file for seg. */ Elf32_Word p_memsz; /* number of bytes in mem. for seg. */ Elf32_Word p_flags; /* flags */ Elf32_Word p_align; /* memory alignment */ } Elf32_Phdr; typedef struct { Elf64_Half p_type; /* entry type */ Elf64_Half p_flags; /* flags */ Elf64_Off p_offset; /* offset */ Elf64_Addr p_vaddr; /* virtual address */ Elf64_Addr p_paddr; /* physical address */ Elf64_Xword p_filesz; /* file size */ Elf64_Xword p_memsz; /* memory size */ Elf64_Xword p_align; /* memory & file alignment */ } Elf64_Phdr; 其中各个字段说明： p_type 此数组元素描述的段的类型，或者如何解释此数组元素的信息。具体如下图。 p_offset 此成员给出从文件头到该段第一个字节的偏移。 p_vaddr 此成员给出段的第一个字节将被放到内存中的虚拟地址。 p_paddr 此成员仅用于与物理地址相关的系统中。因为 System V 忽略所有应用程序的物理地址信息，此字段对与可执行文件和共享目标文件而言具体内容是指定的。 p_filesz 此成员给出段在文件映像中所占的字节数。可以为 0。 p_memsz 此成员给出段在内存映像中占用的字节数。可以为 0。 p_flags 此成员给出与段相关的标志。 p_align 可加载的进程段的 p_vaddr 和 p_offset 取值必须合适，相对于对页面大小的取模而言。此成员给出段在文件中和内存中如何 对齐。数值 0 和 1 表示不需要对齐。否则 p_align 应该是个正整数，并且是 2 的幂次数，p_vaddr 和 p_offset 对 p_align 取模后应该相等。 节区（Sections） x@ubuntu:~/work/libs/libraries$ readelf -S output/build/app/glibc/tmem There are 37 section headers, starting at offset 0x45f0: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000000318 00000318 000000000000002e 0000000000000000 A 0 0 1 [ 2] .note.gnu.propert NOTE 0000000000000348 00000348 0000000000000020 0000000000000000 A 0 0 8 [ 3] .note.gnu.build-i NOTE 0000000000000368 00000368 0000000000000024 0000000000000000 A 0 0 4 [ 4] .note.ABI-tag NOTE 000000000000038c 0000038c 0000000000000020 0000000000000000 A 0 0 4 [ 5] .gnu.hash GNU_HASH 00000000000003b0 000003b0 0000000000000050 0000000000000000 A 6 0 8 [ 6] .dynsym DYNSYM 0000000000000400 00000400 00000000000001c8 0000000000000018 A 7 1 8 [ 7] .dynstr STRTAB 00000000000005c8 000005c8 00000000000000ff 0000000000000000 A 0 0 1 [ 8] .gnu.version VERSYM 00000000000006c8 000006c8 0000000000000026 0000000000000002 A 6 0 2 [ 9] .gnu.version_r VERNEED 00000000000006f0 000006f0 0000000000000020 0000000000000000 A 7 1 8 [10] .rela.dyn RELA 0000000000000710 00000710 00000000000000c0 0000000000000018 A 6 0 8 [11] .rela.plt RELA 00000000000007d0 000007d0 0000000000000048 0000000000000018 AI 6 24 8 [12] .init PROGBITS 0000000000001000 00001000 000000000000001b 0000000000000000 AX 0 0 4 [13] .plt PROGBITS 0000000000001020 00001020 0000000000000040 0000000000000010 AX 0 0 16 [14] .plt.got PROGBITS 0000000000001060 00001060 0000000000000010 0000000000000010 AX 0 0 16 [15] .plt.sec PROGBITS 0000000000001070 00001070 0000000000000030 0000000000000010 AX 0 0 16 [16] .text PROGBITS 00000000000010a0 000010a0 00000000000001f5 0000000000000000 AX 0 0 16 [17] .fini PROGBITS 0000000000001298 00001298 000000000000000d 0000000000000000 AX 0 0 4 [18] .rodata PROGBITS 0000000000002000 00002000 0000000000000037 0000000000000000 A 0 0 4 [19] .eh_frame_hdr PROGBITS 0000000000002038 00002038 000000000000004c 0000000000000000 A 0 0 4 [20] .eh_frame PROGBITS 0000000000002088 00002088 0000000000000128 0000000000000000 A 0 0 8 [21] .init_array INIT_ARRAY 0000000000003d98 00002d98 0000000000000008 0000000000000008 WA 0 0 8 [22] .fini_array FINI_ARRAY 0000000000003da0 00002da0 0000000000000008 0000000000000008 WA 0 0 8 [23] .dynamic DYNAMIC 0000000000003da8 00002da8 0000000000000200 0000000000000010 WA 7 0 8 [24] .got PROGBITS 0000000000003fa8 00002fa8 0000000000000058 0000000000000008 WA 0 0 8 [25] .data PROGBITS 0000000000004000 00003000 0000000000000010 0000000000000000 WA 0 0 8 [26] .bss NOBITS 0000000000004010 00003010 0000000000000008 0000000000000000 WA 0 0 1 [27] .comment PROGBITS 0000000000000000 00003010 000000000000002b 0000000000000001 MS 0 0 1 [28] .debug_aranges PROGBITS 0000000000000000 0000303b 0000000000000040 0000000000000000 0 0 1 [29] .debug_info PROGBITS 0000000000000000 0000307b 000000000000046e 0000000000000000 0 0 1 [30] .debug_abbrev PROGBITS 0000000000000000 000034e9 0000000000000136 0000000000000000 0 0 1 [31] .debug_line PROGBITS 0000000000000000 0000361f 0000000000000174 0000000000000000 0 0 1 [32] .debug_str PROGBITS 0000000000000000 00003793 00000000000003a3 0000000000000001 MS 0 0 1 [33] .debug_ranges PROGBITS 0000000000000000 00003b36 0000000000000030 0000000000000000 0 0 1 [34] .symtab SYMTAB 0000000000000000 00003b68 00000000000006f0 0000000000000018 35 56 8 [35] .strtab STRTAB 0000000000000000 00004258 000000000000022d 0000000000000000 0 0 1 [36] .shstrtab STRTAB 0000000000000000 00004485 0000000000000168 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific) 节区中包含目标文件中的所有信息，除了:ELF 头部、程序头部表格、节区头部表格。节区满足以下条件: 目标文件中的每个节区都有对应的节区头部描述它，反过来，有节区头部不意 味着有节区。 每个节区占用文件中一个连续字节区域(这个区域可能长度为 0)。 文件中的节区不能重叠，不允许一个字节存在于两个节区中的情况发生。 目标文件中可能包含非活动空间(INACTIVE SPACE)。这些区域不属于任何头部和节区。 每个节区头部数据结构描述: /* Section Header */ typedef struct { Elf32_Word sh_name; /* name - index into section header string table section */ Elf32_Word sh_type; /* type */ Elf32_Word sh_flags; /* flags */ Elf32_Addr sh_addr; /* address */ Elf32_Off sh_offset; /* file offset */ Elf32_Word sh_size; /* section size */ Elf32_Word sh_link; /* section header table index link */ Elf32_Word sh_info; /* extra information */ Elf32_Word sh_addralign; /* address alignment */ Elf32_Word sh_entsize; /* section entry size */ } Elf32_Shdr; typedef struct { Elf64_Half sh_name; /* section name */ Elf64_Half sh_type; /* section type */ Elf64_Xword sh_flags; /* section flags */ Elf64_Addr sh_addr; /* virtual address */ Elf64_Off sh_offset; /* file offset */ Elf64_Xword sh_size; /* section size */ Elf64_Half sh_link; /* link to another */ Elf64_Half sh_info; /* misc info */ Elf64_Xword sh_addralign; /* memory alignment */ Elf64_Xword sh_entsize; /* table entry size */ } Elf64_Shdr; 各个字段的解释: sh_type 字段 节区类型定义： sh_flags 字段定义了一个节区中包含的内容是否可以修改、是否可以执行等信息。 如果一个标志位被设置，则该位取值为 1。 定义的各位都设置为 0。 SHF_WRITE: 节区包含进程执行过程中将可写的数据。 SHF_ALLOC: 此节区在进程执行过程中占用内存。某些控制节区并不出现于目标文件的内存映像中，对于那些节区，此位应设置为 0。 SHF_EXECINSTR: 节区包含可执行的机器指令。 SHF_MASKPROC: 所有包含于此掩码中的四位都用于处理器专用的语义。 根据节区类型的不同，sh_link 和 sh_info 的具体含义也有所不同： 特殊节区 以 . 开头的节区名称是系统保留的。应用程序可以使用没有前缀的节区名称，以避 免与系统节区冲突。 目标文件格式允许人们定义不在上述列表中的节区。 保留给处理器体系结构的节区名称一般构成为 : 处理器体系结构名称简写 + 节区名称。 处理器名称应该与 e_machine 中使用的名称相同。例如 .FOO.psect 街区是由FOO 体系结构定义的 psect 节区。 查看 section 内容 我们可以使用 readelf -x SecNum 来打印出不同 section 中的内容。但是，无奈其输出结果都是机器码，对我们人来说不具备可读性。所以我们换用 binutils 包中的另外一个工具 objdump 来看看这些 sections 中到底具有哪些内容 源码如下： #include #include int gl = 5; static void t() { char* p2 = malloc(32); snprintf(p2, 32, \"hello, I am here 2\"); } int main(int argc, char **argv) { char* p1 = malloc(32); snprintf(p1, 32, \"hello, I am here 1\"); printf(\"111111111111\\n\"); t(); return 0; } .text x@ubuntu:~/work/libs/libraries$ objdump -d -j .text output/build/app/glibc/tmem output/build/app/glibc/tmem: file format elf64-x86-64 Disassembly of section .text: 00000000000010a0 : 10a0: f3 0f 1e fa endbr64 10a4: 31 ed xor %ebp,%ebp 10a6: 49 89 d1 mov %rdx,%r9 10a9: 5e pop %rsi 10aa: 48 89 e2 mov %rsp,%rdx 10ad: 48 83 e4 f0 and $0xfffffffffffffff0,%rsp 10b1: 50 push %rax 10b2: 54 push %rsp 10b3: 4c 8d 05 d6 01 00 00 lea 0x1d6(%rip),%r8 # 1290 10ba: 48 8d 0d 5f 01 00 00 lea 0x15f(%rip),%rcx # 1220 10c1: 48 8d 3d fb 00 00 00 lea 0xfb(%rip),%rdi # 11c3 10c8: ff 15 12 2f 00 00 callq *0x2f12(%rip) # 3fe0 10ce: f4 hlt 10cf: 90 nop 00000000000010d0 : 10d0: 48 8d 3d 39 2f 00 00 lea 0x2f39(%rip),%rdi # 4010 10d7: 48 8d 05 32 2f 00 00 lea 0x2f32(%rip),%rax # 4010 10de: 48 39 f8 cmp %rdi,%rax 10e1: 74 15 je 10f8 10e3: 48 8b 05 ee 2e 00 00 mov 0x2eee(%rip),%rax # 3fd8 10ea: 48 85 c0 test %rax,%rax 10ed: 74 09 je 10f8 10ef: ff e0 jmpq *%rax 10f1: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 10f8: c3 retq 10f9: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 0000000000001100 : 1100: 48 8d 3d 09 2f 00 00 lea 0x2f09(%rip),%rdi # 4010 1107: 48 8d 35 02 2f 00 00 lea 0x2f02(%rip),%rsi # 4010 110e: 48 29 fe sub %rdi,%rsi 1111: 48 89 f0 mov %rsi,%rax 1114: 48 c1 ee 3f shr $0x3f,%rsi 1118: 48 c1 f8 03 sar $0x3,%rax 111c: 48 01 c6 add %rax,%rsi 111f: 48 d1 fe sar %rsi 1122: 74 14 je 1138 1124: 48 8b 05 c5 2e 00 00 mov 0x2ec5(%rip),%rax # 3ff0 112b: 48 85 c0 test %rax,%rax 112e: 74 08 je 1138 1130: ff e0 jmpq *%rax 1132: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 1138: c3 retq 1139: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 0000000000001140 : 1140: f3 0f 1e fa endbr64 1144: 80 3d c5 2e 00 00 00 cmpb $0x0,0x2ec5(%rip) # 4010 114b: 75 2b jne 1178 114d: 55 push %rbp 114e: 48 83 3d a2 2e 00 00 cmpq $0x0,0x2ea2(%rip) # 3ff8 1155: 00 1156: 48 89 e5 mov %rsp,%rbp 1159: 74 0c je 1167 115b: 48 8b 3d a6 2e 00 00 mov 0x2ea6(%rip),%rdi # 4008 1162: e8 f9 fe ff ff callq 1060 1167: e8 64 ff ff ff callq 10d0 116c: c6 05 9d 2e 00 00 01 movb $0x1,0x2e9d(%rip) # 4010 1173: 5d pop %rbp 1174: c3 retq 1175: 0f 1f 00 nopl (%rax) 1178: c3 retq 1179: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 0000000000001180 : 1180: f3 0f 1e fa endbr64 1184: e9 77 ff ff ff jmpq 1100 0000000000001189 : 1189: f3 0f 1e fa endbr64 118d: 55 push %rbp 118e: 48 89 e5 mov %rsp,%rbp 1191: 48 83 ec 10 sub $0x10,%rsp 1195: bf 20 00 00 00 mov $0x20,%edi 119a: e8 f1 fe ff ff callq 1090 119f: 48 89 45 f8 mov %rax,-0x8(%rbp) 11a3: 48 8b 45 f8 mov -0x8(%rbp),%rax 11a7: 48 8d 15 56 0e 00 00 lea 0xe56(%rip),%rdx # 2004 11ae: be 20 00 00 00 mov $0x20,%esi 11b3: 48 89 c7 mov %rax,%rdi 11b6: b8 00 00 00 00 mov $0x0,%eax 11bb: e8 c0 fe ff ff callq 1080 11c0: 90 nop 11c1: c9 leaveq 11c2: c3 retq 00000000000011c3 : 11c3: f3 0f 1e fa endbr64 11c7: 55 push %rbp 11c8: 48 89 e5 mov %rsp,%rbp 11cb: 48 83 ec 20 sub $0x20,%rsp 11cf: 89 7d ec mov %edi,-0x14(%rbp) 11d2: 48 89 75 e0 mov %rsi,-0x20(%rbp) 11d6: bf 20 00 00 00 mov $0x20,%edi 11db: e8 b0 fe ff ff callq 1090 11e0: 48 89 45 f8 mov %rax,-0x8(%rbp) 11e4: 48 8b 45 f8 mov -0x8(%rbp),%rax 11e8: 48 8d 15 28 0e 00 00 lea 0xe28(%rip),%rdx # 2017 11ef: be 20 00 00 00 mov $0x20,%esi 11f4: 48 89 c7 mov %rax,%rdi 11f7: b8 00 00 00 00 mov $0x0,%eax 11fc: e8 7f fe ff ff callq 1080 1201: 48 8d 3d 22 0e 00 00 lea 0xe22(%rip),%rdi # 202a 1208: e8 63 fe ff ff callq 1070 120d: b8 00 00 00 00 mov $0x0,%eax 1212: e8 72 ff ff ff callq 1189 1217: b8 00 00 00 00 mov $0x0,%eax 121c: c9 leaveq 121d: c3 retq 121e: 66 90 xchg %ax,%ax 0000000000001220 : 1220: f3 0f 1e fa endbr64 1224: 41 57 push %r15 1226: 4c 8d 3d 6b 2b 00 00 lea 0x2b6b(%rip),%r15 # 3d98 122d: 41 56 push %r14 122f: 49 89 d6 mov %rdx,%r14 1232: 41 55 push %r13 1234: 49 89 f5 mov %rsi,%r13 1237: 41 54 push %r12 1239: 41 89 fc mov %edi,%r12d 123c: 55 push %rbp 123d: 48 8d 2d 5c 2b 00 00 lea 0x2b5c(%rip),%rbp # 3da0 1244: 53 push %rbx 1245: 4c 29 fd sub %r15,%rbp 1248: 48 83 ec 08 sub $0x8,%rsp 124c: e8 af fd ff ff callq 1000 1251: 48 c1 fd 03 sar $0x3,%rbp 1255: 74 1f je 1276 1257: 31 db xor %ebx,%ebx 1259: 0f 1f 80 00 00 00 00 nopl 0x0(%rax) 1260: 4c 89 f2 mov %r14,%rdx 1263: 4c 89 ee mov %r13,%rsi 1266: 44 89 e7 mov %r12d,%edi 1269: 41 ff 14 df callq *(%r15,%rbx,8) 126d: 48 83 c3 01 add $0x1,%rbx 1271: 48 39 dd cmp %rbx,%rbp 1274: 75 ea jne 1260 1276: 48 83 c4 08 add $0x8,%rsp 127a: 5b pop %rbx 127b: 5d pop %rbp 127c: 41 5c pop %r12 127e: 41 5d pop %r13 1280: 41 5e pop %r14 1282: 41 5f pop %r15 1284: c3 retq 1285: 66 66 2e 0f 1f 84 00 data16 nopw %cs:0x0(%rax,%rax,1) 128c: 00 00 00 00 0000000000001290 : 1290: f3 0f 1e fa endbr64 1294: c3 retq .data x@ubuntu:~/work/libs/libraries$ objdump -d -j .data output/build/app/glibc/tmem output/build/app/glibc/tmem: file format elf64-x86-64 Disassembly of section .data: 0000000000004000 : ... 0000000000004008 : 4008: 08 40 00 00 00 00 00 00 .@...... 0000000000004010 : 4010: 05 00 00 00 .rodata x@ubuntu:~/work/libs/libraries$ objdump -d -j .rodata output/build/app/glibc/tmem output/build/app/glibc/tmem: file format elf64-x86-64 Disassembly of section .rodata: 0000000000002000 : 2000: 01 00 02 00 68 65 6c 6c 6f 2c 20 49 20 61 6d 20 ....hello, I am 2010: 68 65 72 65 20 32 00 68 65 6c 6c 6f 2c 20 49 20 here 2.hello, I 2020: 61 6d 20 68 65 72 65 20 31 00 31 31 31 31 31 31 am here 1.111111 2030: 31 31 31 31 31 31 00 111111. .strtab x@ubuntu:~/work/libs/libraries$ readelf -x 35 output/build/app/glibc/tmem Hex dump of section '.strtab': 0x00000000 00637274 73747566 662e6300 64657265 .crtstuff.c.dere 0x00000010 67697374 65725f74 6d5f636c 6f6e6573 gister_tm_clones 0x00000020 005f5f64 6f5f676c 6f62616c 5f64746f .__do_global_dto 0x00000030 72735f61 75780063 6f6d706c 65746564 rs_aux.completed 0x00000040 2e383036 31005f5f 646f5f67 6c6f6261 .8061.__do_globa 0x00000050 6c5f6474 6f72735f 6175785f 66696e69 l_dtors_aux_fini 0x00000060 5f617272 61795f65 6e747279 00667261 _array_entry.fra 0x00000070 6d655f64 756d6d79 005f5f66 72616d65 me_dummy.__frame 0x00000080 5f64756d 6d795f69 6e69745f 61727261 _dummy_init_arra 0x00000090 795f656e 74727900 745f6d65 6d2e6300 y_entry.t_mem.c. 0x000000a0 5f5f4652 414d455f 454e445f 5f005f5f __FRAME_END__.__ 0x000000b0 696e6974 5f617272 61795f65 6e64005f init_array_end._ 0x000000c0 5f64736f 5f68616e 646c6500 5f44594e _dso_handle._DYN 0x000000d0 414d4943 005f5f69 6e69745f 61727261 AMIC.__init_arra 0x000000e0 795f7374 61727400 5f5f474e 555f4548 y_start.__GNU_EH 0x000000f0 5f465241 4d455f48 4452005f 5f544d43 _FRAME_HDR.__TMC 0x00000100 5f454e44 5f5f005f 474c4f42 414c5f4f _END__._GLOBAL_O 0x00000110 46465345 545f5441 424c455f 005f5f6c FFSET_TABLE_.__l 0x00000120 6962635f 6373755f 66696e69 005f4954 ibc_csu_fini._IT 0x00000130 4d5f6465 72656769 73746572 544d436c M_deregisterTMCl 0x00000140 6f6e6554 61626c65 00707574 73404047 oneTable.puts@@G 0x00000150 4c494243 5f322e32 2e35005f 65646174 LIBC_2.2.5._edat 0x00000160 6100736e 7072696e 74664040 474c4942 a.snprintf@@GLIB 0x00000170 435f322e 322e3500 5f5f6c69 62635f73 C_2.2.5.__libc_s 0x00000180 74617274 5f6d6169 6e404047 4c494243 tart_main@@GLIBC 0x00000190 5f322e32 2e35005f 5f646174 615f7374 _2.2.5.__data_st 0x000001a0 61727400 5f5f676d 6f6e5f73 74617274 art.__gmon_start 0x000001b0 5f5f005f 494f5f73 7464696e 5f757365 __._IO_stdin_use 0x000001c0 64005f5f 6c696263 5f637375 5f696e69 d.__libc_csu_ini 0x000001d0 74006d61 6c6c6f63 4040474c 4942435f t.malloc@@GLIBC_ 0x000001e0 322e322e 35005f5f 6273735f 73746172 2.2.5.__bss_star 0x000001f0 74006d61 696e0067 6c005f49 544d5f72 t.main.gl._ITM_r 0x00000200 65676973 74657254 4d436c6f 6e655461 egisterTMCloneTa 0x00000210 626c6500 5f5f6378 615f6669 6e616c69 ble.__cxa_finali 0x00000220 7a654040 474c4942 435f322e 322e3500 ze@@GLIBC_2.2.5. strtab section 中存储着的都是以字符为分割符的字符串，这些字符串所表示的内容，通常是程序中定义的函数名称、所定义过的变量名称等等。。。当对象文件中其他地方需要和一个这样的字符串相关联的时候，往往会在对应的地方存储 .strtab section 中的索引值。比方下面将要介绍的符号表 .symtab section 中，有一个条目是用来描述符号 gv_inited 的，那么在该条目中就会有一个字段(st_name)记录着字符串 gv_inited 在 .strtab section 中的索引 7 。 .shstrtab 也是字符串表，只不过其中存储的是 section 的名字，而非所用函数或者变量的名称。字符串表在真正链接和生成进程映像过程中是不需要使用的，但是其对我们调试程序来说就特别有帮助，因为我们人看起来最舒服的还是自然形式的字符串，而非像天书一样的数字符号。前面使用objdump来反汇编 .text section 的时候，之所以能看到定义了函数 sum_func ，那也是因为存在这个字符串表的原因。当然起关键作用的，还是符号表 .symtab section 在其中作为中介，下面我们就来看看符号表。 .symtab x@ubuntu:~/work/libs/libraries$ readelf -s output/build/app/glibc/tmem Symbol table '.dynsym' contains 20 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.2.5 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND snprintf@GLIBC_2.2.5 (2) 4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2) 5: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 6: 0000000000000000 0 FUNC GLOBAL DEFAULT UND malloc@GLIBC_2.2.5 (2) 7: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable 8: 0000000000004014 0 NOTYPE GLOBAL DEFAULT 25 _edata 9: 0000000000004000 0 NOTYPE GLOBAL DEFAULT 25 __data_start 10: 0000000000004018 0 NOTYPE GLOBAL DEFAULT 26 _end 11: 0000000000004010 4 OBJECT GLOBAL DEFAULT 25 gl 12: 0000000000000000 0 FUNC WEAK DEFAULT UND __cxa_finalize@GLIBC_2.2.5 (2) 13: 0000000000004000 0 NOTYPE WEAK DEFAULT 25 data_start 14: 0000000000002000 4 OBJECT GLOBAL DEFAULT 18 _IO_stdin_used 15: 0000000000001220 101 FUNC GLOBAL DEFAULT 16 __libc_csu_init 16: 00000000000010a0 47 FUNC GLOBAL DEFAULT 16 _start 17: 0000000000004014 0 NOTYPE GLOBAL DEFAULT 26 __bss_start 18: 00000000000011c3 91 FUNC GLOBAL DEFAULT 16 main 19: 0000000000001290 5 FUNC GLOBAL DEFAULT 16 __libc_csu_fini Symbol table '.symtab' contains 75 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000318 0 SECTION LOCAL DEFAULT 1 2: 0000000000000348 0 SECTION LOCAL DEFAULT 2 3: 0000000000000368 0 SECTION LOCAL DEFAULT 3 4: 000000000000038c 0 SECTION LOCAL DEFAULT 4 5: 00000000000003b0 0 SECTION LOCAL DEFAULT 5 6: 0000000000000410 0 SECTION LOCAL DEFAULT 6 7: 00000000000005f0 0 SECTION LOCAL DEFAULT 7 8: 00000000000006f2 0 SECTION LOCAL DEFAULT 8 9: 0000000000000720 0 SECTION LOCAL DEFAULT 9 10: 0000000000000740 0 SECTION LOCAL DEFAULT 10 11: 0000000000000800 0 SECTION LOCAL DEFAULT 11 12: 0000000000001000 0 SECTION LOCAL DEFAULT 12 13: 0000000000001020 0 SECTION LOCAL DEFAULT 13 14: 0000000000001060 0 SECTION LOCAL DEFAULT 14 15: 0000000000001070 0 SECTION LOCAL DEFAULT 15 16: 00000000000010a0 0 SECTION LOCAL DEFAULT 16 17: 0000000000001298 0 SECTION LOCAL DEFAULT 17 18: 0000000000002000 0 SECTION LOCAL DEFAULT 18 19: 0000000000002038 0 SECTION LOCAL DEFAULT 19 20: 0000000000002088 0 SECTION LOCAL DEFAULT 20 21: 0000000000003d98 0 SECTION LOCAL DEFAULT 21 22: 0000000000003da0 0 SECTION LOCAL DEFAULT 22 23: 0000000000003da8 0 SECTION LOCAL DEFAULT 23 24: 0000000000003fa8 0 SECTION LOCAL DEFAULT 24 25: 0000000000004000 0 SECTION LOCAL DEFAULT 25 26: 0000000000004014 0 SECTION LOCAL DEFAULT 26 27: 0000000000000000 0 SECTION LOCAL DEFAULT 27 28: 0000000000000000 0 SECTION LOCAL DEFAULT 28 29: 0000000000000000 0 SECTION LOCAL DEFAULT 29 30: 0000000000000000 0 SECTION LOCAL DEFAULT 30 31: 0000000000000000 0 SECTION LOCAL DEFAULT 31 32: 0000000000000000 0 SECTION LOCAL DEFAULT 32 33: 0000000000000000 0 SECTION LOCAL DEFAULT 33 34: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 35: 00000000000010d0 0 FUNC LOCAL DEFAULT 16 deregister_tm_clones 36: 0000000000001100 0 FUNC LOCAL DEFAULT 16 register_tm_clones 37: 0000000000001140 0 FUNC LOCAL DEFAULT 16 __do_global_dtors_aux 38: 0000000000004014 1 OBJECT LOCAL DEFAULT 26 completed.8061 39: 0000000000003da0 0 OBJECT LOCAL DEFAULT 22 __do_global_dtors_aux_fin 40: 0000000000001180 0 FUNC LOCAL DEFAULT 16 frame_dummy 41: 0000000000003d98 0 OBJECT LOCAL DEFAULT 21 __frame_dummy_init_array_ 42: 0000000000000000 0 FILE LOCAL DEFAULT ABS t_mem.c 43: 0000000000001189 58 FUNC LOCAL DEFAULT 16 t 44: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 45: 00000000000021ac 0 OBJECT LOCAL DEFAULT 20 __FRAME_END__ 46: 0000000000000000 0 FILE LOCAL DEFAULT ABS 47: 0000000000001298 0 FUNC LOCAL DEFAULT 17 _fini 48: 0000000000003da0 0 NOTYPE LOCAL DEFAULT 21 __init_array_end 49: 0000000000004008 0 OBJECT LOCAL DEFAULT 25 __dso_handle 50: 0000000000003da8 0 OBJECT LOCAL DEFAULT 23 _DYNAMIC 51: 0000000000003d98 0 NOTYPE LOCAL DEFAULT 21 __init_array_start 52: 0000000000002038 0 NOTYPE LOCAL DEFAULT 19 __GNU_EH_FRAME_HDR 53: 0000000000004018 0 OBJECT LOCAL DEFAULT 25 __TMC_END__ 54: 0000000000003fa8 0 OBJECT LOCAL DEFAULT 24 _GLOBAL_OFFSET_TABLE_ 55: 0000000000001000 0 FUNC LOCAL DEFAULT 12 _init 56: 0000000000001290 5 FUNC GLOBAL DEFAULT 16 __libc_csu_fini 57: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 58: 0000000000004000 0 NOTYPE WEAK DEFAULT 25 data_start 59: 0000000000000000 0 FUNC GLOBAL DEFAULT UND puts@@GLIBC_2.2.5 60: 0000000000004014 0 NOTYPE GLOBAL DEFAULT 25 _edata 61: 0000000000000000 0 FUNC GLOBAL DEFAULT UND snprintf@@GLIBC_2.2.5 62: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ 63: 0000000000004000 0 NOTYPE GLOBAL DEFAULT 25 __data_start 64: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 65: 0000000000002000 4 OBJECT GLOBAL DEFAULT 18 _IO_stdin_used 66: 0000000000001220 101 FUNC GLOBAL DEFAULT 16 __libc_csu_init 67: 0000000000000000 0 FUNC GLOBAL DEFAULT UND malloc@@GLIBC_2.2.5 68: 0000000000004018 0 NOTYPE GLOBAL DEFAULT 26 _end 69: 00000000000010a0 47 FUNC GLOBAL DEFAULT 16 _start 70: 0000000000004014 0 NOTYPE GLOBAL DEFAULT 26 __bss_start 71: 00000000000011c3 91 FUNC GLOBAL DEFAULT 16 main 72: 0000000000004010 4 OBJECT GLOBAL DEFAULT 25 gl 73: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable 74: 0000000000000000 0 FUNC WEAK DEFAULT UND __cxa_finalize@@GLIBC_2.2 ELF 符号类型 STT_OBJECT 表示和该符号对应的是一个数据对象 STT_FUNC 表示该符号对应的是函数 STT_SECTION 表示该符号和一个 section 相关，这种符号用于重定位。 ELF 符号的绑定类型 STB_LOCA 仅本对象文件可见 STB_GLOBAL 全局可见 STB_WEAK ELF 符号的值 在可重定位文件中，如果该符号对应的section index(上面的Ndx)为SHN_COMMON，那么符号的值表示的是该数据的对齐要求。 在可重定位文件中，除去上面那条定义的符号，对于其他的符号来说，其值表示的是对应 section 内的偏移值。 在可执行文件或者动态库中，符号的值表示的是运行时的内存地址。 重定位 假如在所产生的对象文件 test.o 中有对函数 sum_func 的引用，这对我们的x386结构来说，其实就是一条call指令。既然 sum_func 是定义在 sum.o 中的，那对 test.o 来说，它就是一个外部引用。所以，汇编器在产生 test.o 的时候，它会产生一个重定位条目。重定位条目中会包含以下几类东西： 它会包含一个符号表中一个条目的索引，因为这样我们才知道它具体是哪个符号需要被重定位的； 它会包含一个 .text section 中的地址单元的偏移值。原本这个偏移值处的地址单元里面应该存放着 call 指令的操作数。对上面来说，也就是函数 sum_func 的地址，但是目前这个地址汇编器还不知道。 它还会包含一个tag，以指明该重定位属于何种类型。当我们用链接器去链接这个对象文件的时候，链接器会遍历所有的重定位条目，碰到像 sum_func 这样的外部引用，它会找到 sum_func 的确切地址，并且把它写回到上面 call 指令操作数所占用的那个地址单元。像这样的操作，称之为重定位操作。link editor 和 dynamic linker 都要完成一些重定位操作，只不过后者的动作更加复杂，因为它是在运行时动态完成的。概括一下，所谓重定位操作就是：“汇编的时候产生一个空坐位，上面用红纸写着要坐在这个座位上的人的名字，然后连接器在开会前安排那个人坐上去”。如前面我们说过的，对象文件中的重定位条目，会构成一个个单独的 section。这些 section 的名字，常会是这样的形式：\".rel.XXX\"。其中XXX表示的是这些重定位条目所作用到的section，如 .text section。重定位条目所构成的section需要和另外两个section产生关联：符号表section(表示要重定位的是哪一个符号)以及受影响地址单元所在的section。下面使用工具来查看重定位section： x@ubuntu:~/work/libs/libraries$ readelf -r output/build/app/glibc/tmem Relocation section '.rela.dyn' at offset 0x740 contains 8 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000003d98 000000000008 R_X86_64_RELATIVE 1180 000000003da0 000000000008 R_X86_64_RELATIVE 1140 000000004008 000000000008 R_X86_64_RELATIVE 4008 000000003fd8 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0 000000003fe0 000400000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000003fe8 000500000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000003ff0 000700000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0 000000003ff8 000c00000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0 Relocation section '.rela.plt' at offset 0x800 contains 3 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000003fc0 000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000003fc8 000300000007 R_X86_64_JUMP_SLO 0000000000000000 snprintf@GLIBC_2.2.5 + 0 000000003fd0 000600000007 R_X86_64_JUMP_SLO 0000000000000000 malloc@GLIBC_2.2.5 + 0 r_offset 对于可重定位文件.o来说，就是地址单元的偏移值；对可执行文件或者动态库来说，就是该地址单元的运行时地址。 segments(段) 链接器在链接可执行文件或动态库的过程中，它会把来自不同可重定位对象文件中的相同名称的 section 合并起来构成同名的 section。接着，它又会把带有相同属性(比方都是只读并可加载的)的 section 都合并成所谓 segments(段)。segments 作为链接器的输出，常被称为输出section。我们开发者可以控制哪些不同.o文件的sections来最后合并构成不同名称的 segments。如何控制呢，就是通过 linker script 来指定。 一个单独的 segment 通常会包含几个不同的 sections，比方一个可被加载的、只读的segment 通常就会包括可执行代码section .text、只读的数据section .rodata以及给动态链接器使用的符号section .dymsym等等。section 是被链接器使用的，但是 segments 是被加载器所使用的。加载器会将所需要的 segment 加载到内存空间中运行。和用 sections header table 来指定一个可重定位文件中到底有哪些 sections 一样。在一个可执行文件或者动态库中，也需要有一种信息结构来指出包含有哪些 segments。这种信息结构就是 program header table。 x@ubuntu:~/work/libs/libraries$ readelf -l output/build/app/glibc/tmem Elf file type is DYN (Shared object file) Entry point 0x10a0 There are 13 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000002d8 0x00000000000002d8 R 0x8 INTERP 0x0000000000000318 0x0000000000000318 0x0000000000000318 0x000000000000002e 0x000000000000002e R 0x1 [Requesting program interpreter: /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000848 0x0000000000000848 R 0x1000 LOAD 0x0000000000001000 0x0000000000001000 0x0000000000001000 0x00000000000002a5 0x00000000000002a5 R E 0x1000 LOAD 0x0000000000002000 0x0000000000002000 0x0000000000002000 0x00000000000001b0 0x00000000000001b0 R 0x1000 LOAD 0x0000000000002d98 0x0000000000003d98 0x0000000000003d98 0x000000000000027c 0x0000000000000280 RW 0x1000 DYNAMIC 0x0000000000002da8 0x0000000000003da8 0x0000000000003da8 0x0000000000000200 0x0000000000000200 RW 0x8 NOTE 0x0000000000000348 0x0000000000000348 0x0000000000000348 0x0000000000000020 0x0000000000000020 R 0x8 NOTE 0x0000000000000368 0x0000000000000368 0x0000000000000368 0x0000000000000044 0x0000000000000044 R 0x4 GNU_PROPERTY 0x0000000000000348 0x0000000000000348 0x0000000000000348 0x0000000000000020 0x0000000000000020 R 0x8 GNU_EH_FRAME 0x0000000000002038 0x0000000000002038 0x0000000000002038 0x000000000000004c 0x000000000000004c R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000002d98 0x0000000000003d98 0x0000000000003d98 0x0000000000000268 0x0000000000000268 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 03 .init .plt .plt.got .plt.sec .text .fini 04 .rodata .eh_frame_hdr .eh_frame 05 .init_array .fini_array .dynamic .got .data .bss 06 .dynamic 07 .note.gnu.property 08 .note.gnu.build-id .note.ABI-tag 09 .note.gnu.property 10 .eh_frame_hdr 11 12 .init_array .fini_array .dynamic .got 结果显示，在可执行文件 output/build/app/glibc/tmem 中，总共有13个 segments。同时，该结果也很明白显示出了哪些 section 映射到哪一个 segment 当中去。比方在索引为2的那个segment 中，总共有10个 sections 映射进来。注意segment 有三个标志: R 、W 和 E。这个表示该segment是可读，可写，也可执行的。 类型为PHDR的segment，用来包含程序头表本身。 类型为INTERP的segment只包含一个 section，那就是 .interp。在这个section中，包含了动态链接过程中所使用的解释器路径和名称。在Linux里面，这个解释器实际上就是 /lib/ ，这可以通过下面的 hexdump 看出来： Offset 表示当前段在二进制文件中的开始位置。 x@ubuntu:~/work/libs/libraries$ hexdump -s 0x318 -n 46 -C output/build/app/glibc/tmem 00000318 2f 75 73 72 2f 6c 6f 63 61 6c 2f 67 6c 69 62 63 |/usr/local/glibc| 00000328 32 2e 33 37 2f 6c 69 62 2f 6c 64 2d 6c 69 6e 75 |2.37/lib/ld-linu| 00000338 78 2d 78 38 36 2d 36 34 2e 73 6f 2e 32 00 |x-x86-64.so.2.| 00000346 为什么会有这样的一个 segment？这是因为我们写的应用程序通常都需要使用动态链接库.so。我们还是先大致说说程序在linux里面是怎么样运行起来的吧。当你在 shell 中敲入一个命令要执行时，内核会帮我们创建一个新的进程，它在往这个新进程的进程空间里面加载进可执行程序的代码段和数据段后，也会加载进动态连接器(在Linux里面通常就是 /lib/ld-linux.so 符号链接所指向的那个程序，它本省就是一个动态库)的代码段和数据。在这之后，内核将控制传递给动态链接库里面的代码。动态连接器接下来负责加载该命令应用程序所需要使用的各种动态库。加载完毕，动态连接器才将控制传递给应用程序的main函数。如此，你的应用程序才得以运行。 在应用程序中，会使用很多定义在动态库中的函数。最最基础的比方C函数库(其本身就是一个动态库)中定义的函数，每个应用程序总要使用到，就像我们test程序中使用到的 printf 函数。为了使得应用程序能够正确使用动态库，动态连接器在加载动态库后，它还会做更进一步的链接，这就是所谓的动态链接。为了让动态连接器能成功的完成动态链接过程，在前面运行的link editor需要在应用程序可执行文件中生成数个特殊的 sections，比方 .dynamic、.dynsym、.got和.plt等等。 接下来的数个 segments 中，最重要的是三个 segment：代码段，数据段和堆栈段。代码段和堆栈段的 VirtAddr 列的值分别为 0x0000000000001000 和 0x0000000000003d98。这是什么意思呢？这是说对应的段要加载在进程虚拟地址空间中的起始地址。虽然在可执行文件中规定了 text segment和 data segment 的起始地址，但是最终，在内存中的这些段的真正起始地址，却可能不是这样的，因为在动态链接器加载这些段的时候，需要考虑到页面对齐的因素。为什么？因为像x86这样的架构，它给内存单元分配读写权限的最小单位是页(page)而不是字节。也就是说，它能规定从某个页开始、连续多少页是只读的。却不能规定从某个页内的哪一个字节开始，连续多少个字节是只读的。因为x86架构中，一个page大小是4k，所以，动态链接器在加载 segment 到虚拟内存中的时候，其真实的起始地址的低12位都是零，也即以 0x1000 对齐。 真实的进程中的内存空间信息： (gdb) i proc mappings process 1041268 Mapped address spaces: Start Addr End Addr Size Offset objfile 0x555555554000 0x555555555000 0x1000 0x0 /home/zhangkaiyuan/work/libs/libraries/output/build/app/glibc/tmem 0x555555555000 0x555555556000 0x1000 0x1000 /home/zhangkaiyuan/work/libs/libraries/output/build/app/glibc/tmem 0x555555556000 0x555555557000 0x1000 0x2000 /home/zhangkaiyuan/work/libs/libraries/output/build/app/glibc/tmem 0x555555557000 0x555555558000 0x1000 0x2000 /home/zhangkaiyuan/work/libs/libraries/output/build/app/glibc/tmem 0x555555558000 0x555555559000 0x1000 0x3000 /home/zhangkaiyuan/work/libs/libraries/output/build/app/glibc/tmem 0x555555559000 0x55555557a000 0x21000 0x0 [heap] 0x7ffff7df2000 0x7ffff7df4000 0x2000 0x0 0x7ffff7df4000 0x7ffff7e1c000 0x28000 0x0 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7e1c000 0x7ffff7f57000 0x13b000 0x28000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7f57000 0x7ffff7fad000 0x56000 0x163000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fad000 0x7ffff7fae000 0x1000 0x1b9000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fae000 0x7ffff7fb2000 0x4000 0x1b9000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fb2000 0x7ffff7fb4000 0x2000 0x1bd000 /usr/local/glibc2.37/lib/libc.so.6 0x7ffff7fb4000 0x7ffff7fc3000 0xf000 0x0 0x7ffff7fc3000 0x7ffff7fc7000 0x4000 0x0 [vvar] 0x7ffff7fc7000 0x7ffff7fc9000 0x2000 0x0 [vdso] 0x7ffff7fc9000 0x7ffff7fca000 0x1000 0x0 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7fca000 0x7ffff7fef000 0x25000 0x1000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7fef000 0x7ffff7ffa000 0xb000 0x26000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7ffb000 0x7ffff7ffd000 0x2000 0x31000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffff7ffd000 0x7ffff7fff000 0x2000 0x33000 /usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 0x7ffffffde000 0x7ffffffff000 0x21000 0x0 [stack] 0xffffffffff600000 0xffffffffff601000 0x1000 0x0 [vsyscall] "},"computer/linux/dynamic_library/dynamicLibrary.html":{"url":"computer/linux/dynamic_library/dynamicLibrary.html","title":"2 动态库","keywords":"","body":" 重定位 "},"computer/linux/dynamic_library/relocation/relocation.html":{"url":"computer/linux/dynamic_library/relocation/relocation.html","title":"2.1 重定位","keywords":"","body":" 动态库重定位 动态库重定位的两种方式： 加载时重定位，又称静态加载或隐式加载，在链接时将其链接进目标文件。 运行时重定位，动态加载或显式加载，在程序中动态加载动态库，当运行到加载处时，才会将动态库加载进来。动态加载需要包含的头文件：#includeapi：// 打开动态链接库void dlopen (const char filename, int flag); //取函数void dlsym(void handle, char *symbol); // 关闭动态链接库int dlclose (void *handle); 本文测试代码 动态库源码 #include #include int mem_tst = 2; int memLibTest() { char* p1 = malloc(32); snprintf(p1, 32, \"hello, I am here in .so\"); mem_tst = 9; int i = 0; i = 10; return 0; } 测试主程序 #define _GNU_SOURCE #include #include #include #include #include \"t_mem_lib.h\" static int gl = 5; static void t() { char* p2 = malloc(32); snprintf(p2, 32, \"hello, I am here 2\"); } static int header_handler(struct dl_phdr_info* info, size_t size, void* data) { printf(\"name=%s (%d segments) address=%p\\n\", info->dlpi_name, info->dlpi_phnum, (void*)info->dlpi_addr); for (int j = 0; j dlpi_phnum; j++) { printf(\"\\t\\t header %2d: address=%10p\\n\", j, (void*) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr)); printf(\"\\t\\t\\t type=%u, flags=0x%X\\n\", info->dlpi_phdr[j].p_type, info->dlpi_phdr[j].p_flags); } printf(\"\\n\"); return 0; } extern int mem_tst; int main(int argc, char **argv) { char* p1 = malloc(32); snprintf(p1, 32, \"hello, I am here 1\"); printf(\"111111111111\\n\"); gl = 10; dl_iterate_phdr(header_handler, NULL); memLibTest(); t(); int i = 5; while(i--) { sleep(1); } return 0; } 动态库中变量的重定位过程 源码编译完成，通过readelf -r libtstmem.so命令，看下动态重定位区的数据： x@ubuntu:~/work/libs/libraries$ readelf -r output/build/app/glibc/libtstmem.so Relocation section '.rela.dyn' at offset 0x4d8 contains 8 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000003de8 000000000008 R_X86_64_RELATIVE 1130 000000003df0 000000000008 R_X86_64_RELATIVE 10f0 000000004028 000000000008 R_X86_64_RELATIVE 4028 000000003fd8 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0 000000003fe0 000700000006 R_X86_64_GLOB_DAT 0000000000004030 mem_tst + 0 000000003fe8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000003ff0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0 000000003ff8 000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0 Relocation section '.rela.plt' at offset 0x598 contains 2 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000004018 000200000007 R_X86_64_JUMP_SLO 0000000000000000 snprintf@GLIBC_2.2.5 + 0 000000004020 000400000007 R_X86_64_JUMP_SLO 0000000000000000 malloc@GLIBC_2.2.5 + 0 .rel.dyn表示动态重定位区。动态库在加载过程中的重定位就是使用.rel.dyn重定位数据。可以看到变量 mem_tst 在动态库中的偏移量 Sym. Value（0000000000004030）处，变量真实地址存放在 库中偏移量 Offset（000000003fe0）处。 通过命令 objdump -d -j .text libtstmem.so，dump出动态库中的汇编指令如下，截取一部分： x@ubuntu:~/work/libs/libraries$ objdump -d -j .text output/build/app/glibc/libtstmem.so output/build/app/glibc/libtstmem.so: file format elf64-x86-64 Disassembly of section .text: 0000000000001139 : 1139: f3 0f 1e fa endbr64 113d: 55 push %rbp 113e: 48 89 e5 mov %rsp,%rbp 1141: 48 83 ec 10 sub $0x10,%rsp 1145: bf 20 00 00 00 mov $0x20,%edi 114a: e8 21 ff ff ff callq 1070 114f: 48 89 45 f8 mov %rax,-0x8(%rbp) 1153: 48 8b 45 f8 mov -0x8(%rbp),%rax 1157: 48 8d 15 a2 0e 00 00 lea 0xea2(%rip),%rdx # 2000 115e: be 20 00 00 00 mov $0x20,%esi 1163: 48 89 c7 mov %rax,%rdi 1166: b8 00 00 00 00 mov $0x0,%eax 116b: e8 f0 fe ff ff callq 1060 1170: 48 8b 05 69 2e 00 00 mov 0x2e69(%rip),%rax # 3fe0 1177: c7 00 09 00 00 00 movl $0x9,(%rax) 117d: c7 45 f4 00 00 00 00 movl $0x0,-0xc(%rbp) 1184: c7 45 f4 0a 00 00 00 movl $0xa,-0xc(%rbp) 118b: b8 00 00 00 00 mov $0x0,%eax 1190: c9 leaveq 1191: c3 retq 汇编指令中mov 0x2e69(%rip),%rax # 3fe0 mem_tst@@Base-0x50 语句，把变量的地址放到rax寄存器中movl $0x9,(%rax) 语句，将rax寄存器地址处的值设置为立即数0x9 下面启用gdb分析变量 mem_tst 在内存中的地址 x@ubuntu:~/work/libs/libraries$ gdb ./output/build/app/glibc/tmem GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: . Find the GDB manual and other documentation resources online at: . For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from ./output/build/app/glibc/tmem... (gdb) b 36 Breakpoint 1 at 0x13ee: file /home/x/work/libs/libraries/app/glibc/t_mem.c, line 36. (gdb) r Starting program: /home/x/work/libs/libraries/output/build/app/glibc/tmem 111111111111 name= (13 segments) address=0x555555554000 header 0: address=0x555555554040 type=6, flags=0x4 header 1: address=0x555555554318 type=3, flags=0x4 header 2: address=0x555555554000 type=1, flags=0x4 header 3: address=0x555555555000 type=1, flags=0x5 header 4: address=0x555555556000 type=1, flags=0x4 header 5: address=0x555555557d60 type=1, flags=0x6 header 6: address=0x555555557d70 type=2, flags=0x6 header 7: address=0x555555554348 type=4, flags=0x4 header 8: address=0x555555554368 type=4, flags=0x4 header 9: address=0x555555554348 type=1685382483, flags=0x4 header 10: address=0x555555556098 type=1685382480, flags=0x4 header 11: address=0x555555554000 type=1685382481, flags=0x6 header 12: address=0x555555557d60 type=1685382482, flags=0x4 name=linux-vdso.so.1 (4 segments) address=0x7ffff7fc7000 header 0: address=0x7ffff7fc7000 type=1, flags=0x5 header 1: address=0x7ffff7fc73e0 type=2, flags=0x4 header 2: address=0x7ffff7fc7500 type=4, flags=0x4 header 3: address=0x7ffff7fc7554 type=1685382480, flags=0x4 name=/home/x/work/libs/libraries/output/build/app/glibc/libtstmem.so (11 segments) address=0x7ffff7fbc000 header 0: address=0x7ffff7fbc000 type=1, flags=0x4 header 1: address=0x7ffff7fbd000 type=1, flags=0x5 header 2: address=0x7ffff7fbe000 type=1, flags=0x4 header 3: address=0x7ffff7fbfde8 type=1, flags=0x6 header 4: address=0x7ffff7fbfdf8 type=2, flags=0x6 header 5: address=0x7ffff7fbc2a8 type=4, flags=0x4 header 6: address=0x7ffff7fbc2c8 type=4, flags=0x4 header 7: address=0x7ffff7fbc2a8 type=1685382483, flags=0x4 header 8: address=0x7ffff7fbe018 type=1685382480, flags=0x4 header 9: address=0x7ffff7fbc000 type=1685382481, flags=0x6 header 10: address=0x7ffff7fbfde8 type=1685382482, flags=0x4 name=/usr/local/glibc2.37/lib/libc.so.6 (14 segments) address=0x7ffff7def000 header 0: address=0x7ffff7def040 type=6, flags=0x4 header 1: address=0x7ffff7f77b20 type=3, flags=0x4 header 2: address=0x7ffff7def000 type=1, flags=0x4 header 3: address=0x7ffff7e17000 type=1, flags=0x5 header 4: address=0x7ffff7f52000 type=1, flags=0x4 header 5: address=0x7ffff7fa9c58 type=1, flags=0x6 header 6: address=0x7ffff7facbc0 type=2, flags=0x6 header 7: address=0x7ffff7def350 type=4, flags=0x4 header 8: address=0x7ffff7def380 type=4, flags=0x4 header 9: address=0x7ffff7fa9c58 type=7, flags=0x4 header 10: address=0x7ffff7def350 type=1685382483, flags=0x4 header 11: address=0x7ffff7f77b50 type=1685382480, flags=0x4 header 12: address=0x7ffff7def000 type=1685382481, flags=0x6 header 13: address=0x7ffff7fa9c58 type=1685382482, flags=0x4 name=/usr/local/glibc2.37/lib/ld-linux-x86-64.so.2 (11 segments) address=0x7ffff7fc9000 header 0: address=0x7ffff7fc9000 type=1, flags=0x4 header 1: address=0x7ffff7fca000 type=1, flags=0x5 header 2: address=0x7ffff7fef000 type=1, flags=0x4 header 3: address=0x7ffff7ffbaa0 type=1, flags=0x6 header 4: address=0x7ffff7ffcec0 type=2, flags=0x6 header 5: address=0x7ffff7fc92a8 type=4, flags=0x4 header 6: address=0x7ffff7fc92c8 type=4, flags=0x4 header 7: address=0x7ffff7fc92a8 type=1685382483, flags=0x4 header 8: address=0x7ffff7ff5460 type=1685382480, flags=0x4 header 9: address=0x7ffff7fc9000 type=1685382481, flags=0x6 header 10: address=0x7ffff7ffbaa0 type=1685382482, flags=0x4 Breakpoint 1, main (argc=1, argv=0x7fffffffe1b8) at /home/x/work/libs/libraries/app/glibc/t_mem.c:36 36 t(); (gdb) 可以看到 libtstmem.so 库加载到了内存的 address=0x7ffff7fbc000 地址处，根据上面分析，变量 mem_tst 在库中的偏移为 0x4030，所以应该在 0x7ffff7fbc000 + 0x4030 = 0x7ffff7fc0030 地址处，下面我们打印 mem_tst 地址 (gdb) print &mem_tst $1 = (int *) 0x7ffff7fc0030 (gdb) Cool，和我们计算出来的地址匹配，现在我们再来打印 0x3fe0 偏移处的内容，即 0x7ffff7fbc000 + 0x3fe0 = 0x7ffff7fbffe0 地址处的内容，看一下是不是变量 mem_tst 的真实地址： (gdb) x /8xb 0x7ffff7fbffe0 0x7ffff7fbffe0: 0x30 0x00 0xfc 0xf7 0xff 0x7f 0x00 0x00 (gdb) 处理器为小端格式，所以 0x7ffff7fbffe0 地址处的内容为 0x7ffff7fc0030，和打印出的变量 mem_tst 地址相同。 下面我们再来分析汇编指令 mov 0x2e69(%rip),%rax # 3fe0 mem_tst@@Base-0x50 中0x2e69的由来，该条汇编指令地址在动态库中的偏移量为0x1170，它的下一条指令的地址偏移为 0x1177，变量 mem_tst 地址保存在重定位区 .rela.dyn 中，在动态库中的偏移量为 0x3fe0，此时 0x3fe0 - 0x1177 的计算结果（0x2e69）即为 mov 指令中rip 的偏移。通过adb disassemble 命令打印汇编代码如下： (gdb) disassemble Dump of assembler code for function memLibTest: 0x00007ffff7fbd139 : endbr64 0x00007ffff7fbd13d : push %rbp 0x00007ffff7fbd13e : mov %rsp,%rbp 0x00007ffff7fbd141 : sub $0x10,%rsp 0x00007ffff7fbd145 : mov $0x20,%edi 0x00007ffff7fbd14a : callq 0x7ffff7fbd070 0x00007ffff7fbd14f : mov %rax,-0x8(%rbp) 0x00007ffff7fbd153 : mov -0x8(%rbp),%rax 0x00007ffff7fbd157 : lea 0xea2(%rip),%rdx # 0x7ffff7fbe000 0x00007ffff7fbd15e : mov $0x20,%esi 0x00007ffff7fbd163 : mov %rax,%rdi 0x00007ffff7fbd166 : mov $0x0,%eax 0x00007ffff7fbd16b : callq 0x7ffff7fbd060 => 0x00007ffff7fbd170 : mov 0x2e69(%rip),%rax # 0x7ffff7fbffe0 0x00007ffff7fbd177 : movl $0x9,(%rax) 0x00007ffff7fbd17d : movl $0x0,-0xc(%rbp) 0x00007ffff7fbd184 : movl $0xa,-0xc(%rbp) 0x00007ffff7fbd18b : mov $0x0,%eax 0x00007ffff7fbd190 : leaveq 0x00007ffff7fbd191 : retq End of assembler dump. 程序执行到 mov 0x2e69(%rip),%rax # 0x7ffff7fbffe0 这条指令，对变量 mem_tst 的寻址方式为下一条指令的虚拟地址 + 偏移（0x2e69）即为该全局变量的实际地址，此处 mem_tst 寻到的地址即为 0x00007ffff7fbd177 + 0x2e69 = 0x7ffff7fbffe0，和重定位区 .rela.dyn 中 mem_tst 的 Offset 保存的变量的真实地址相同。注：x64新增的RIP相对寻址， 是 64 位程序全局变量惯用的寻址方式，仅仅只是因为 rip 的值是现成的（其它寄存器就不灵），偏移的值也是确定的（此例中偏移值 0x2e69），那么，这个全局变量的地址也就确定了，不用执行，反汇编就能确定此值。 动态库中函数的重定位过程 先改造以下动态库代码，如下： #include #include int mem_tst = 2; int ts() { mem_tst = mem_tst + 3; return 0; } int memLibTest() { char* p1 = malloc(32); snprintf(p1, 32, \"hello, I am here in .so\"); mem_tst = 9; ts(); int i = 0; i = 10; return 0; } dump出来的汇编代码如下： x@ubuntu:~/work/libs/libraries$ objdump -d -j .text output/build/app/glibc/libtstmem.so output/build/app/glibc/libtstmem.so: file format elf64-x86-64 Disassembly of section .text: 0000000000001159 : 1159: f3 0f 1e fa endbr64 115d: 55 push %rbp 115e: 48 89 e5 mov %rsp,%rbp 1161: 48 8b 05 78 2e 00 00 mov 0x2e78(%rip),%rax # 3fe0 1168: 8b 00 mov (%rax),%eax 116a: 8d 50 03 lea 0x3(%rax),%edx 116d: 48 8b 05 6c 2e 00 00 mov 0x2e6c(%rip),%rax # 3fe0 1174: 89 10 mov %edx,(%rax) 1176: b8 00 00 00 00 mov $0x0,%eax 117b: 5d pop %rbp 117c: c3 retq 000000000000117d : 117d: f3 0f 1e fa endbr64 1181: 55 push %rbp 1182: 48 89 e5 mov %rsp,%rbp 1185: 48 83 ec 10 sub $0x10,%rsp 1189: bf 20 00 00 00 mov $0x20,%edi 118e: e8 fd fe ff ff callq 1090 1193: 48 89 45 f8 mov %rax,-0x8(%rbp) 1197: 48 8b 45 f8 mov -0x8(%rbp),%rax 119b: 48 8d 15 5e 0e 00 00 lea 0xe5e(%rip),%rdx # 2000 11a2: be 20 00 00 00 mov $0x20,%esi 11a7: 48 89 c7 mov %rax,%rdi 11aa: b8 00 00 00 00 mov $0x0,%eax 11af: e8 bc fe ff ff callq 1070 11b4: 48 8b 05 25 2e 00 00 mov 0x2e25(%rip),%rax # 3fe0 11bb: c7 00 09 00 00 00 movl $0x9,(%rax) 11c1: b8 00 00 00 00 mov $0x0,%eax 11c6: e8 b5 fe ff ff callq 1080 11cb: c7 45 f4 00 00 00 00 movl $0x0,-0xc(%rbp) 11d2: c7 45 f4 0a 00 00 00 movl $0xa,-0xc(%rbp) 11d9: b8 00 00 00 00 mov $0x0,%eax 11de: c9 leaveq 11df: c3 retq 可以看出在 e8 b5 fe ff ff callq 1080 ts@plt 处调用了ts函数。继续查看动态重定向区信息 x@ubuntu:~/work/libs/libraries$ readelf -r output/build/app/glibc/libtstmem.so Relocation section '.rela.dyn' at offset 0x500 contains 8 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000003de8 000000000008 R_X86_64_RELATIVE 1150 000000003df0 000000000008 R_X86_64_RELATIVE 1110 000000004030 000000000008 R_X86_64_RELATIVE 4030 000000003fd8 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0 000000003fe0 000800000006 R_X86_64_GLOB_DAT 0000000000004038 mem_tst + 0 000000003fe8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000003ff0 000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0 000000003ff8 000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0 Relocation section '.rela.plt' at offset 0x5c0 contains 3 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000004018 000200000007 R_X86_64_JUMP_SLO 0000000000000000 snprintf@GLIBC_2.2.5 + 0 000000004020 000900000007 R_X86_64_JUMP_SLO 0000000000001159 ts + 0 000000004028 000400000007 R_X86_64_JUMP_SLO 0000000000000000 malloc@GLIBC_2.2.5 + 0 "},"literature/literature.html":{"url":"literature/literature.html","title":"文学","keywords":"","body":" 诗词 "},"literature/poetry/poetry.html":{"url":"literature/poetry/poetry.html","title":"诗词","keywords":"","body":" 苏轼 "},"literature/poetry/sushi/sushi.html":{"url":"literature/poetry/sushi/sushi.html","title":"苏轼","keywords":"","body":" 《定风波·莫听穿林打叶声》 "},"literature/poetry/sushi/1.html":{"url":"literature/poetry/sushi/1.html","title":"《定风波·莫听穿林打叶声》","keywords":"","body":" 《定风波·莫听穿林打叶声》 （宋代：苏轼） 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。 "}}