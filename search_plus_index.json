{"./":{"url":"./","title":"Introduction","keywords":"","body":" 计算机科学 文学 "},"computer/computer.html":{"url":"computer/computer.html","title":"计算机","keywords":"","body":" glibc "},"computer/glibc/glibc.html":{"url":"computer/glibc/glibc.html","title":"glibc","keywords":"","body":" glibc官网 虚拟地址分配和分页 "},"computer/glibc/memoryManagement/memoryManagement.html":{"url":"computer/glibc/memoryManagement/memoryManagement.html","title":"1 虚拟地址分配和分页","keywords":"","body":" Memory management 进程内存概念(Process Memory Concepts) GNU 分配器(The GNU Allocator) 页表 "},"computer/glibc/memoryManagement/ProcessMemoryConcepts.html":{"url":"computer/glibc/memoryManagement/ProcessMemoryConcepts.html","title":"1.1 进程内存概念","keywords":"","body":" 进程内存概念 进程可用的最基本资源之一是内存。系统组织内存的方式有很多种，但在典型的一种方式中，每个进程都有一个线性虚拟地址空间，地址从零到某个巨大的最大值。它不必是连续的；即，并非所有这些地址实际中都可用于存储数据。 虚拟内存被分成页（典型值为 4 KB）。支持虚拟内存的每一页的是实际内存的一页（称为帧）或一些辅助存储，通常是磁盘空间。磁盘空间可能是交换空间或只是一些普通的磁盘文件。实际上，一个全为零的页有时根本不存在一个标志说它是全零的。 实际内存或后备存储的同一帧可以支持属于多个进程的多个虚拟页。通常是这种情况，例如，GNU C 库代码占用的虚拟内存。包含 printf 函数的同一个实际内存帧支持每个在其程序中调用 printf 的现有进程中的虚拟内存页。 为了让程序访问虚拟页的任何部分，该页此时必须由实际帧支持或连接到实际帧。但是由于虚拟内存通常比实际内存多得多，因此页必须定期在实际内存和后备存储之间来回移动，当进程需要访问它们时进入实际内存，然后在不再需要时退回到后备存储。这种移动称为分页。 当一个程序试图访问一个当时没有实际内存支持的页时，这被称为页错误。当发生页错误时，内核暂停进程，将页放入实际页帧中（这称为“分页（paging in）”或“缺页中断（faulting in）”），然后恢复进程，以便从进程的角度来看，页一直在实际内存中。事实上，对于进程来说，所有页似乎总是在实际内存中。除了一件事：通常为几纳秒的指令的执行时间突然变得非常非常长（因为内核通常必须执行I/O才能完成换页（page-in））。对于对此敏感的程序，锁定页面中描述的功能可以控制它。 在每个虚拟地址空间内，一个进程必须跟踪哪些地址是什么，该进程称为内存分配。分配通常会让人想到分配稀缺资源，但在虚拟内存的情况下，这不是主要目标，因为它通常比任何人需要的要多得多。进程内的内存分配主要只是确保同一字节的内存不用于存储两个不同的东西。 进程以两种主要方式分配内存：通过 exec 和以编程方式。实际上，fork是第三种方式，但不是很有趣。请参阅创建进程。 Exec是为进程创建虚拟地址空间，将其基本程序加载到其中并执行程序的操作。它由“exec”函数族（例如 execl）完成。该操作获取一个程序文件（可执行文件），它分配空间以加载可执行文件中的所有数据，加载它并将控制权转移给它。该数据最值得注意的是程序的指令（文本），还有程序中的文字和常量，甚至一些变量：具有静态存储类的 C 变量（请参阅 C 程序中的内存分配）。 一旦该程序开始执行，它就会使用程序分配来获得额外的内存。在带有 GNU C 库的 C 程序中，有两种程序分配方式：自动分配和动态分配。请参阅 C 程序中的内存分配。 内存映射 I/O 是另一种形式的动态虚拟内存分配。将内存映射到文件意味着声明某个进程地址范围的内容应与指定的常规文件的内容相同。系统使虚拟内存最初包含文件的内容，如果您修改内存，系统会将相同的修改写入文件。请注意，由于虚拟内存和页错误的魔力，在程序访问虚拟内存之前，系统没有理由执行 I/O 来读取文件或为其内容分配实际内存。请参阅内存映射 I/O。 正如它以编程方式分配内存一样，程序可以以编程方式解除分配（释放）它。您无法释放 exec 分配的内存。当程序退出或执行时，你可能会说它的所有内存都被释放了，但是由于在这两种情况下地址空间都不存在了，这一点真的没有实际意义。请参阅程序终止。 "},"computer/glibc/memoryManagement/GNUAllocator.html":{"url":"computer/glibc/memoryManagement/GNUAllocator.html","title":"1.2 GNU 分配器","keywords":"","body":" GNU 分配器 GNU C 库中的 malloc 实现派生自 ptmalloc (pthreads malloc)，而后者又派生自 dlmalloc (由Doug Lea在1987年开发完成，这是Android系统中使用的内存分配器。而Linux系统中采用的是ptmalloc，ptmalloc在dlmalloc的基础上进行了改进，以更好适应多线程)。这个 malloc 可以根据它们的大小和可能由用户控制的某些参数以两种不同的方式分配内存。最常见的方法是从大的连续内存区域分配部分内存（称为块）并管理这些区域以优化它们的使用并减少不可用块形式的浪费。传统上，系统堆被设置为一个大内存区域，但 GNU C 库 malloc 实现维护多个这样的区域以优化它们在多线程应用程序中的使用。每个这样的区域在内部被称为一个arena。 与其他版本相反，GNU C 库中的 malloc 不会将块大小四舍五入为 2 的幂，无论是大的还是小的大小。相邻的块可以在空闲时合并，无论它们的大小是多少。这使得该实现适用于各种分配模式，而通常不会因碎片而导致大量内存浪费。多个 arena 的存在允许多个线程同时在单独的 arena 中分配内存，从而提高性能。 内存分配的另一种方式是非常大的块，即比页大得多。这些请求使用 mmap 分配（匿名或通过 /dev/zero；请参阅内存映射 I/O）。这具有很大的优势，即这些块在被释放时会立即返回到系统。因此，不会发生大块被“锁定”在较小块之间的情况，即使在调用 free 之后也会浪费内存。要使用的 mmap 的大小阈值是动态的，并根据程序的分配模式进行调整。mallopt 可用于使用 M_MMAP_THRESHOLD 静态调整阈值，并且可以使用 M_MMAP_MAX 完全禁用 mmap 的使用；请参阅 Malloc 可调参数。 GNU 分配器的更详细的技术描述保存在 GNU C 库 wiki 中。请参阅wiki。 可以使用您自己的自定义 malloc 代替 GNU C 库提供的内置分配器。请参阅替换 malloc。 基本内存分配（malloc） 要分配一块内存，请调用 malloc。此函数的原型位于 stdlib.h 中。 函数：void * malloc (size t size) 此函数返回一个指向新分配的块 size 字节长的指针，如果无法分配块，则返回一个空指针（设置 errno）。 块的内容是未定义的；您必须自己初始化它（或使用 calloc 代替；请参阅分配已清除空间）。 您可以将 malloc 的结果存储到任何指针变量中而无需强制转换，因为 ISO C 在必要时会自动将类型 void * 转换为另一种类型的指针。但是，如果需要类型但上下文未指定类型，则强制类型转换是必要的。请记住，在为字符串分配空间时，malloc 的参数必须是字符串长度加一。这是因为字符串以不计入字符串“长度”但需要空间的空字符终止。 请记住，在为字符串分配空间时，malloc 的参数必须是字符串长度加一。这是因为字符串以不计入字符串“长度”但需要空间的空字符终止。 malloc 为您提供的块保证是对齐的，以便它可以保存任何类型的数据。在 GNU 系统上，地址在 32 位系统上始终是 8 的倍数，在 64 位系统上始终是 16 的倍数。很少需要任何更高的边界（例如页面边界）；对于这些情况，请使用 aligned_alloc 或 posix_memalign（请参阅分配对齐的内存块）。 释放malloc分配的内存（free） 当您不再需要使用 malloc 获得的块时，请使用 free 函数使该块可再次分配。此函数的原型位于 stdlib.h 中 函数：void free (void *ptr) 有时，free 实际上可以将内存返回给操作系统，并使进程更小。通常，它所能做的就是允许稍后调用 malloc 来重用空间。同时，该空间作为 malloc 内部使用的空闲列表的一部分保留在您的程序中。 在程序结束时释放块没有意义，因为当进程终止时，程序的所有空间都归还给系统。 更改块的大小（realloc） 您可以通过调用 realloc 或 reallocarray 使块更长。这些函数在 stdlib.h 中声明。 函数：void realloc (void ptr, size t newsize) realloc 函数将地址为 ptr 的块的大小更改为 newsize。由于块末尾之后的空间可能正在使用中，realloc 可能会发现有必要将块复制到有更多可用空间的新地址。realloc 的返回值是块的新地址。如果需要移动块，realloc 会复制旧的内容。 如果你为 ptr 传递一个空指针，realloc 的行为就像’malloc (newsize)'。否则，如果 newsize 为零，realloc 释放块并返回 NULL。否则，如果 realloc 无法重新分配请求的大小，则返回 NULL 并设置 errno；原始块不受干扰。 函数：void reallocarray (void ptr, size t nmemb, size t size) reallocarray 函数将地址为 ptr 的块的大小更改为足够长以包含 nmemb 元素的向量（vector），每个元素的大小为size。它等效于“realloc (ptr, nmemb * size)”，但如果乘法溢出，reallocarray 会安全失败，方法是将 errno 设置为 ENOMEM，返回一个空指针，并保持原始块不变。 当分配块的新大小是可能溢出的乘法结果时，应使用 reallocarray 而不是 realloc。 与 malloc 一样，如果没有可用的内存空间使块变大，realloc 和 reallocarray 可能会返回空指针。发生这种情况时，原始块保持不变；它没有被修改或搬移。 您还可以使用 realloc 或 reallocarray 使块更小。这样做的原因是为了避免在只需要一点内存空间时占用大量内存空间。在几种分配实现中，有时需要复制一个块，因此如果没有其他可用空间，它可能会失败。 分配已清理空间（calloc） 函数 calloc 分配内存并将其清除为零。它在 stdlib.h 中声明。 函数：void * calloc (size t count, size t eltsize) 此函数分配一个足够长的块以包含 count 元素的向量，每个元素的大小为 eltsize。在 calloc 返回之前，它的内容被清零。 分配对齐的内存块（aligned_alloc） 在 GNU 系统中 malloc 或 realloc 返回的块的地址始终是 8 的倍数（或 64 位系统上的 16）。如果您需要一个地址是 2 的高次幂的倍数的块，请使用aligned_alloc或posix_memalign。aligned_alloc 和 posix_memalign 在 stdlib.h 中声明。 函数：void * aligned_alloc (size t alignment, size t size) aligned_alloc 函数分配一个size字节的块，其地址是alignment的倍数。alignment必须是 2 的幂，size必须是alignment的倍数。aligned_alloc 函数在出错时返回一个空指针，并将 errno 设置为下列值之一： ENOMEM 没有足够的内存来满足请求。 EINVAL alignment不是 2 的幂。 malloc可调参数（mallopt） 函数：int mallopt (int param, int value)，param 参数指定要设置的参数，value 是要设置的新值。 MMMAP_MAX：使用 mmap 分配的最大块数。将此设置为零将禁用所有 mmap 的使用，该参数的默认值为 65536，通过将环境变量 MALLOC_MMAP_MAX 设置为所需的值，也可以在启动时为进程设置此参数。 MMMAP_THRESHOLD：使用 mmap 系统调用将所有大于此值的块分配到正常堆之外。这样可以保证这些块的内存 free 后可以返回给系统。请注意，小于此阈值的请求仍可能通过 mmap 分配，如果未设置此参数，则默认值设置为 128 KiB，并动态调整阈值以适应程序的分配模式。如果设置了参数，则禁用动态调整，并将值静态设置为输入值，通过将环境变量 MALLOC_MMAP_THRESHOLD 设置为所需的值，也可以在启动时为进程设置此参数。 MPERTURB：如果非零，则在分配内存块（由 calloc 分配时除外）和释放时，根据此参数的某些低位的位填充内存块。这可用于调试未初始化或已释放堆内存的使用。请注意，此选项不保证释放的块将具有任何特定值。它只保证块被释放之前的内容将被覆盖，此参数的默认值为 0，通过将环境变量 MALLOC_PERTURB 设置为所需的值，也可以在启动时为进程设置此参数。 MTOP_PAD：此参数确定当需要扩展 arena 时从系统获得的额外内存量。它还指定缩小 arena 时要保留的字节数。这提供了堆大小的必要滞后，从而可以避免过多的系统调用，此参数的默认值为 0，通过将环境变量 MALLOC_TOP_PAD 设置为所需的值，也可以在启动时为进程设置此参数。 MTRIM_THRESHOLD：这是最顶层的可释放块的最小大小（以字节为单位），它将触发系统调用以将内存返回给系统。如果未设置此参数，则默认值设置为 128 KiB，并动态调整阈值以适应程序的分配模式。如果设置了参数，则禁用动态调整，并将值静态设置为提供的输入，通过将环境变量 MALLOC_TRIM_THRESHOLD 设置为所需的值，也可以在启动时为进程设置此参数。 M_ARENA_TEST：该参数指定在对 arena 数量限制进行测试之前可以创建的 arena 数量。如果设置了 M_ARENA_MAX，则忽略该值。此参数的默认值在 32 位系统上为 2，在 64 位系统上为 8。通过将环境变量 MALLOC_ARENA_TEST 设置为所需的值，也可以在启动时为进程设置此参数。 M_ARENA_MAX：此参数设置要使用的 arena 数量，而与系统中的核心数量无关，此可调参数的默认值为 0，这意味着对 arenas 数量的限制由在线 CPU 内核数决定。对于 32 位系统，限制是在线内核数的两倍，在 64 位系统上，它是八倍的核心在线数量。请注意，默认值并非源自 M_ARENA_TEST 的默认值，而是独立计算的，通过将环境变量 MALLOC_ARENA_MAX 设置为所需的值，也可以在启动时为进程设置此参数。 堆一致性检查（mcheck） 您可以使用 mcheck 函数要求 malloc 检查动态内存的一致性，并使用 LD_PRELOAD 环境变量预加载 malloc 调试库 libc_malloc_debug。这个函数是一个 GNU 扩展，在 mcheck.h 中声明。 函数：int mcheck (void (*abortfn) (enum mcheck_status status)) 调用 mcheck 告诉 malloc 执行偶尔的（occasional）一致性检查。这些将捕获诸如写入超过使用 malloc 分配的块的末尾之类的东西。abortfn 参数是发现不一致时调用的函数。如果您提供一个空指针，则 mcheck 使用一个默认函数，该函数打印一条消息并调用 abort（请参阅终止程序）。您提供的函数使用一个参数调用，该参数说明检测到哪种不一致；其类型如下所述。 一旦你用 malloc 分配了任何东西，再开始分配检查为时已晚。所以 mcheck 在这种情况下什么都不做。如果调用太晚，该函数返回 -1，否则返回 0（成功时）。 安排尽早调用 mcheck 的最简单方法是在链接程序时使用选项“-lmcheck”；那么你根本不需要修改你的程序源。或者，您可以使用调试器在程序启动时插入对 mcheck 的调用，例如，这些 gdb 命令将在程序启动时自动调用 mcheck： (gdb) break main Breakpoint 1, main (argc=2, argv=0xbffff964) at whatever.c:10 (gdb) command 1 Type commands for when breakpoint 1 is hit, one per line. End with a line saying just \"end\". >call mcheck(0) >continue >end (gdb) ... 函数：enum mcheck_status mprobe (void *pointer) mprobe 函数允许您显式检查特定分配块中的不一致。您必须已经在程序开始时调用了 mcheck 来进行偶尔的检查；调用 mprobe 请求在调用时进行额外的一致性检查。 参数 pointer 必须是 malloc 或 realloc 返回的指针。mprobe 返回一个值，说明发现了什么不一致（如果有）。数据类型：enum mcheck_status，这些值如下所述。 MCHECK_DISABLED：在第一次分配之前没有调用 mcheck。无法进行一致性检查。 MCHECK_OK：未检测到不一致。 MCHECK_HEAD：块之前的数据被立即修改。这通常发生在数组索引或指针减少太多时。 MCHECK_TAIL：块之后的数据被立即修改。当数组索引或指针增加太多时，通常会发生这种情况。 MCHECK_FREE：该块已被释放。 在使用 malloc、realloc 和 free 时检查和防止错误的另一种可能性是设置环境变量 MALLOCCHECK。当 MALLOCCHECK 设置为小于 4 的非零值时，将使用一种特殊的（效率较低的）实现，该实现旨在容忍简单的错误，例如使用相同参数的两次 free 调用，或单个字节的溢出（一个错误）。然而，并非所有此类错误都可以得到保护，并且可能导致内存泄漏。与 mcheck 的情况一样，需要预加载 libcmalloc_debug 库以启用 MALLOC_CHECK 功能。如果没有这个预加载的库，设置 MALLOCCHECK 将无效。MALLOCCHECK 存在一个问题：在 SUID 或 SGID 二进制文件中，由于与正常程序行为不同，它可能被利用，或者它现在向标准错误描述符写入一些内容。因此，对于 SUID 和 SGID 二进制文件，默认情况下禁用 MALLOCCHECK 的使用。系统管理员可以通过添加文件 /etc/suid-debug 再次启用它（内容不重要，可以为空）。 使用 MALLOCCHECK 和使用“-lmcheck”链接有什么区别呢？ MALLOCCHECK 与“-lmcheck”正交。添加了“-lmcheck”以实现向后兼容性。MALLOCCHECK 和“-lmcheck”都应该发现相同的错误——但是使用 MALLOCCHECK 你不需要重新编译你的应用程序 任何检测到的堆损坏都会导致进程立即终止。 统计使用malloc分配的内存信息（mallinfo2） 您可以通过调用 mallinfo2 函数获取有关动态内存分配的信息。此函数及其相关数据类型在 malloc.h 中声明；它们是标准 SVID/XPG 版本的扩展。 数据类型：struct mallinfo2 size_t arena 这是 malloc 用 sbrk 分配的内存的总大小，以字节为单位。 size_t ordblks 这是未使用的块数。 内存分配器大小从操作系统内部获取内存块，然后将它们分割以满足各个 malloc 请求。 size_t smblks 该字段未使用。 size_t hblks 这是使用 mmap 分配的块的总数。 size_t hblkhd 这是使用 mmap 分配的内存的总大小，以字节为单位。 size_t usmblks 该字段未使用且始终为 0。 size_t fsmblks 该字段未使用。 size_t uordblks 这是 malloc 分配的块所占用的内存总大小。 size_t fordblks 这是空闲（未使用）块占用的内存总大小。 size_t keepcost 这是通常与堆末端接壤的最高可释放块的大小（即虚拟地址空间数据段的高端）。 函数：struct mallinfo2 mallinfo2 (void) 此函数以 struct mallinfo2 类型的结构返回有关当前动态内存使用情况的信息。 malloc相关函数总结 ``` void *malloc (size_t size) 分配一个 size 字节的块。 void free (void *addr) 释放之前由 malloc 分配的块。 void *realloc (void *addr, size_t size) 使以前由 malloc 分配的块更大或更小，可能通过将其复制到新位置。 void *reallocarray (void *ptr, size_t nmemb, size_t size) 将 malloc 先前分配的块的大小更改为 nmemb * size 个字节，与 realloc 一样。 void *calloc (size_t count, size_t eltsize) 使用 malloc 分配一个 count * eltsize 字节块，并将其内容设置为零。 void *valloc (size_t size) 从页边界开始分配大小字节块。 void *aligned_alloc (size_t size, size_t alignment) 从 alignment 倍数的地址开始分配 size 字节块。 int posix_memalign (void **memptr, size_t alignment, size_t size) 从 alignment 倍数的地址开始分配 size 字节块。 void *memalign (size_t size, size_t boundary) 分配一个 size 字节的块，从一个 boundary 倍数的地址开始。 int mallopt (int param, int value) 调整可调参数。 int mcheck (void (*abortfn) (void)) 告诉 malloc 对动态分配的内存执行偶尔的一致性检查，并在发现不一致时调用 abortfn。 struct mallinfo2 mallinfo2 (void) 返回有关当前动态内存使用情况的信息。 ``` 分配调试 基于不使用垃圾回收动态内存分配的语言进行编程时，一项复杂的任务是查找内存泄漏。长时间运行的程序必须确保动态分配的对象在其生命周期结束时被释放。如果这没有发生，系统迟早会耗尽内存，GNU C 库中的 malloc 实现提供了一些简单的方法来检测此类泄漏并获取一些信息以找到位置。为此，应用程序必须以由环境变量启用的特殊模式启动。如果未启用调试模式，则程序不会受到速度损失。 函数：void mtrace (void) mtrace 函数提供了一种方法来跟踪调用它的程序中的内存分配事件。它在库中默认禁用，可以通过使用 LD_PRELOAD 环境变量预加载调试库 libc_malloc_debug 来启用。 当调用 mtrace 函数时，它会查找名为 MALLOC_TRACE 的环境变量。这个变量应该包含一个有效的文件名。用户必须具有写入权限。如果文件已存在，则将其截断。如果没有设置环境变量或者它没有命名一个可以打开写入的有效文件，则什么也不做。malloc 等的行为没有改变。出于显而易见的原因，如果应用程序安装时设置了 SUID 或 SGID 位，也会发生这种情况。 如果命名文件成功打开，mtrace 会为函数 malloc、realloc 和 free 安装特殊处理程序。从那时起，这些函数的所有使用都被跟踪并协议化到文件中。当然，现在对跟踪函数的所有调用都会有速度损失，因此在正常使用期间不应启用跟踪。 函数：void muntrace (void) 在使用 mtrace 启用跟踪 malloc 调用后，可以调用 muntrace 函数。如果没有（成功）调用 mtrace，则 muntrace 什么也不做。否则，它会卸载 malloc、realloc 和 free 的处理程序，然后关闭协议文件。不再有调用被协议处理，程序再次全速运行。此功能是 GNU 扩展，通常在其他系统上不可用。原型可以在 mcheck.h 中找到。 即使跟踪功能不会影响程序的运行时行为，在所有程序中调用 mtrace 也不是一个好主意。试想一下，您使用 mtrace 调试程序，并且调试会话中使用的所有其他程序也跟踪它们的 malloc 调用。所有程序的输出文件都相同，因此无法使用。因此，只有在为调试而编译时才应该调用 mtrace。因此，程序可以像这样开始： #include int main (int argc, char *argv[]) { #ifdef DEBUGGING mtrace (); #endif ... } 如果您想在程序的整个运行时跟踪调用，这就是您所需要的。或者，您可以随时调用 muntrace 来停止跟踪。甚至可以通过对 mtrace 的新调用再次重新启动跟踪。但这可能会导致不可靠的结果，因为可能会调用未调用的函数。请注意，不仅应用程序使用跟踪函数，库（包括 C 库本身）也使用这些函数。 最后一点也是为什么在程序终止之前调用 muntrace 不是一个好主意的原因。库仅在程序从 main 返回或调用 exit 后才被通知程序终止，因此在此之前无法释放它们使用的内存。所以最好的办法是调用 mtrace 作为程序中的第一个函数，并且永远不要调用 muntrace。因此，该程序跟踪几乎所有 malloc 函数的使用（除了那些由程序的构造函数或使用的库执行的调用）。 解释跟踪 GNU C 库附带的一个程序，它可以解释跟踪并以用户友好的方式输出摘要。该程序称为 mtrace（它实际上是一个 Perl 脚本），它接受一两个参数。在任何情况下，必须指定带有跟踪输出的文件的名称。如果可选参数位于跟踪文件的名称之前，则它必须是生成跟踪的程序的名称。 zhangkaiyuan@ubuntu:$ mtrace tst-mtrace log No memory leaks. 在这种情况下，程序 tst-mtrace 运行并生成了一个跟踪文件日志。mtrace 打印的消息显示代码没有问题，所有分配的内存随后都被释放。 如果我们在上面给出的示例跟踪上调用 mtrace，我们会得到不同的输出： zhangkaiyuan@ubuntu:$ mtrace tst errlog - 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39 - 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39 - 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39 Memory not freed: ----------------- Address Size Caller 0x08064c48 0x14 at /home/drepper/tst.c:33 0x08064c60 0x14 at /home/drepper/tst.c:33 0x08064c78 0x14 at /home/drepper/tst.c:33 0x08064c90 0x14 at /home/drepper/tst.c:33 解释这个输出并不复杂。最多检测两种不同的情况。首先，free 被调用用于从未被分配函数返回的指针。这通常是一个非常糟糕的问题，输出的前三行显示了它的样子。像这样的情况非常罕见，如果它们出现，它们会非常剧烈地出现：程序通常会崩溃。 替换malloc GNU C 库支持用具有相同接口的不同分配器替换内置 malloc 实现。对于动态链接的程序，这通过 ELF 符号插入发生，或者使用共享对象依赖关系或 LD_PRELOAD。对于静态链接，必须先链接 m​​alloc 替换库，然后再链接 libc.a（显式或隐式）。未能提供完整的替换函数集（即应用程序、GNU C 库和其他链接库使用的所有函数）可能导致静态链接失败，并在运行时导致堆损坏和应用程序崩溃。替换函数应该实现它们在 GNU C 库中对应的行为；例如，替换free 也应该保留errno。下表给出了自定义 malloc 必须提供的最小功能集。GNU C 库需要这些与 malloc 相关的函数才能工作。 malloc free calloc realloc GNU C 库中的 malloc 实现提供了库本身不使用的附加功能，但其他系统库和应用程序经常使用这些功能。通用替代 malloc 实现也应该提供这些函数的定义。它们的名称列在下表中。 aligned_alloc malloc_usable_size memalign posix_memalign pvalloc valloc 其他与 malloc 相关的函数（例如 mallopt 或 mallinfo2）在使用替换 malloc 时不会产生任何影响或返回不正确的统计信息。但是，未能替换这些函数通常不会导致崩溃或其他不正确的应用程序行为，但可能会导致静态链接失败。GNU C 库中还有其他函数（reallocarray、strdup 等）未在上面列出，但会将新分配的内存返回给调用者。不支持替换这些函数，并且可能会产生不正确的结果。这些函数的 GNU C 库实现在可用时调用替换分配器函数，因此它们可以与 malloc 替换一起正常工作。 参考 glibc手册03：虚拟地址分配和分页 Virtual Memory Allocation And Paging "},"computer/glibc/memoryManagement/pageTable.html":{"url":"computer/glibc/memoryManagement/pageTable.html","title":"1.3 页表","keywords":"","body":" 页表 引出页目录 对于32位虚拟地址空间，假设页面大小为4K，页表项大小为4字节：一个进程有 4G/4K = 2^20个页面，因为一个页面需要一个页表项来对应，所以，进程的页表项个数也为2^20个，不难得出该进程的页表占用了 2^20 * 4 / 4K = 1024个页面的大小，对于64位的虚拟地址空间来讲，页表规模更大，理论值32000TB，其实，页表页就是存放进程页表的页面，他属于进程的一部分，页表也是以页为基本存储单位的。所以，为了内存的高效使用，一般都不会将这么大规模的页表页存放在连续的内存上，所以，我们引入了页表页的地址索引表，页目录。提供一个目录，这样就变成了一个二维的结构，甚至现在很多计算机有多维的页表结构，也叫多级页表。 以两级页表为例。一级页表中的每个 PTE（page table entry）映射虚拟地址空间的一个 4MB 的片（chunck），每一片由 1024 个连续的页面组成。一级 PTE 指向二级页表的基址。这样 32 位地址空间使用 1024 个一级 PTE 就可以表示。需要的二级页表总条目还是 2^32 / 2^12 = 2^20 个。这里的关键在于如果一级 PTE i 中的页面都未被分配，一级 PTE 就为空。多级页表减少内存占用的关键在于： 如果一级页表中的一个 PTE 为空，那么相应的二级页表就根本不会存在。这是一种巨大的潜在节约。 只有一级页表才需要常驻内存。虚拟内存系统可以在需要时创建、页面调入或者调出二级页表，从而减轻内存的压力。 第二个问题是页表是在内存中，而 MMU 位于 CPU 芯片中，这样每次地址翻译可能都需要先访问一次内存中的页表（CPU L1,L2,L3 Cache Miss 的时候访问内存），效率非常低下。对应的解决方案是引入页表的高速缓存：TLB（Translation Lookaside Buffer）。 ARM中的分页 ARMv7架构支持三种页大小：1MB，64KB和4KB，以4KB页大小，二级页表为例，32bit虚拟地址被划分为3部分： L1 Table Index[31:20]：最高12bit；用于索引一级页表，可索引 2^12=4k 项一级页表 L2 Table Index[19:12]：中间8bit；结合一级页表表项索引二级页表，可索引 2^(12+8) 项二级页表 Page Index[11:0]：最低12bit。结合二级页表表项address[31:12]索引物理地址 地址转换过程，TTBR寄存器Translation base[31:14]和虚拟地址的L1 Table Index[31:20]索引到一级页表物理地址，一级页表Page table base address[31:10]和虚拟地址L2 Table Index[19:12]索引到二级页表物理地址，二级页表Small page base address[31:12]和虚拟地址的Page Index[11:0]索引到物理地址。 ARMv7 4KB Paging页表长啥样 ARMv7 4KB分页机制采用二级页表管理。 一级页表属性见下图： Page table base address[31:10]：线性地址转换二级页表物理地址，用于配合线性地址Page Table找到二级页表物理地址； NS[3]：Non-secure，非安全模式下忽略； Domain[8:5]:域，内存区域的集合，可以定义16个域，划分其访问权限，超越域访问权限时会触发Permission fault。 二级页表属性见下图： Small page base address[31:12]：线性地址转换物理地址，用于配合线性地址offset找到物理地址； XN[0]：Execute-never； C,B[3:2]：定义内部cache属性。 TEX[8:6]：定义外部cache属性。 S[10]：Shareable； nG[11]：not global，指定页表是否是全局的，用于TLB； ARM架构提供了两个页表基址寄存器TTBR0和TTBR1，可以分别用于用户态和内核态。 Kernel中的分页 Linux Kernel分页为了支持不同的CPU体系架构，设计了五级分页模型，如下图所示。五级分页模型是为了兼容X86-64体系架构中的5-Level Paging分页模式 五级分页每级命名分别为页全局目录(PGD)、页4级目录(P4D)、页上级目录(PUD)、页中间目录(PMD)、页表(PTE)。对应的相关宏定义命名如下：#define PGDIR_SHIFT #define P4D_SHIFT #define PUD_SHIFT #define PMD_SHIFT #define PAGE_SHIFT Linux对于页表的操作主要定义了以下函数或宏。这些操作方法也是与体系架构相关的，因此需要按照体系架构的硬件定义去实现。 pgd_offset(mm, addr) 根据入参内存描述符mm和虚拟地址address，找到address在页全局目录中相应表项的线性地址。 pgd_offset_k(addr) 根据入参虚拟地址address和init_mm，找到address在页全局目录中相应表项的线性地址。仅用于内核页表。 p4d_offset(pgd, addr) 根据入参pgd和虚拟地址address，找到address在页四级目录中相应表项的线性地址。 pud_offset(p4d,addr) 根据入参p4d和虚拟地址address，找到address在页上级目录中相应表项的线性地址。 pmd_offset(pud, address) 根据入参pud和虚拟地址address，找到address在页中间目录中相应表项的线性地址。 pte_index(address) 根据入参虚拟地址address，找到address在页表中索引。 set_pgd(pgdp, pgd) 向PGD写入指定的值 set_p4d(p4dp, p4d) 向P4D写入指定的值 ARMv7分页 ARMv7作为32bit CPU架构，其分页一般采用两级分页。第一级为页目录(PGD)，第二级为页映射表(PTE)，页大小为4KB。如下图所示为ARMv7页表映射示意图，与ARMv7硬件4KB分页机制相对应。页表基址寄存器TTBRx(x为0或1)。 TTBRx（Translation Table Base Register x）即页表转换基址寄存器，ARMv7提供了TTBR0和TTBR1两个寄存器，Linux分别将其应用于内核态和用户态。进程地址空间切换实质就是将TTBR0寄存器中Translation Table Base 0 Address修改为当前进程的PGD（页全局目录）。一级页表数量为4096，二级页表数量为256。 分段 分页内存管理，可以说通过多级页表，TLB 等，分页内存管理方法已经相当不错了。那么分页有什么缺点呢？ 共享困难：通过共享页面来实现共享当然是可以的。这里的问题在于我们要保证页面上只包含可以共享的内容并不是一件容易的事儿，因为进程空间是直接映射到页面上的。这样一个页面上很可能包含不能共享的内容（比如既包含代码又包含数据，代码可以共享，而数据不能共享）。早期的 PDP-11 实现的一种解决方法是为指令和数据设置分离的地址空间，分别称为 I 空间和 D 空间（其实这已经和分段很像了）。 程序地址空间受限于虚拟地址：我们将程序全部映射到一个统一的虚拟地址的问题在于不好扩张。不如我们程序的地址按先代码放在一起，然后把数据放在一起，然后再放 XXX，这样其中某一部分的空间扩张起来都会影响到相邻的空间，非常不方便。 上面的问题一个比较直观的解决方法是提供多个独立的地址空间，也就是段（segment）。每个段的长度视具体的段不同而不同，而且是可以在运行期动态改变的。因为每个段都构成了一个独立的地址空间，所以它们可以独立的增长或者减小而不会影响到其他的段。如果一个段比较大，把它整个保存到内存中可能很不方便甚至是不可能的，因此可以对段采用分页管理，只有那些真正需要的页面才会被调入内存。 采用分段和分页结合的方式管理内存，一个地址由两个部分组成：段和段内地址。段内地址又进一步分为页号和页偏移。在进行内存访问时，过程如下： 根据段号找到段描述符（存放段基址）。 检查该段的页表是否在内存中。如果在，则找到它的位置，如果不在，则产生段错误。 检查所请求的虚拟页面的页表项，如果该页面不在内存中则产生缺页中断，如果在内存中就从页表项中取出这个页面在内存中的起始地址 将页面起始地址和偏移量进行拼接得到物理地址，然后完成读写。 每个 Linux 程序都有一个运行时内存映像，也就是各个段的布局，简单如下图所示。 "},"literature/literature.html":{"url":"literature/literature.html","title":"文学","keywords":"","body":" 诗词 "},"literature/poetry/poetry.html":{"url":"literature/poetry/poetry.html","title":"诗词","keywords":"","body":" 苏轼 "},"literature/poetry/sushi/sushi.html":{"url":"literature/poetry/sushi/sushi.html","title":"苏轼","keywords":"","body":" 《定风波·莫听穿林打叶声》 "},"literature/poetry/sushi/1.html":{"url":"literature/poetry/sushi/1.html","title":"《定风波·莫听穿林打叶声》","keywords":"","body":" 《定风波·莫听穿林打叶声》 （宋代：苏轼） 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。 "}}