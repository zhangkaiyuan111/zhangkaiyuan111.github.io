{"./":{"url":"./","title":"Introduction","keywords":"","body":"ebook 介绍 软件架构 安装教程 xxxx xxxx xxxx 使用说明 xxxx xxxx xxxx "},"glibc/glibc.html":{"url":"glibc/glibc.html","title":"1 glibc","keywords":"","body":""},"glibc/memoryManagement/memoryManagement.html":{"url":"glibc/memoryManagement/memoryManagement.html","title":"1 Memory management","keywords":"","body":" Memory management "},"glibc/memoryManagement/malloc.html":{"url":"glibc/memoryManagement/malloc.html","title":"1.1 malloc","keywords":"","body":" malloc Posted on February 10, 2015 by sploitfun I always got fascinated by heap memory. Questions such as How heap memory is obtained from kernel?How efficiently memory is managed?Is it managed by kernel or by library or by application itself?Can heap memory be exploited? were in my mind for quite some time. But only recently I got time to understand about it. So here I would like to share my fascination turned knowledge!! Out there in the wild, many memory allocators are available: dlmalloc – General purpose allocator ptmalloc2 – glibc jemalloc – FreeBSD and Firefox tcmalloc – Google libumem – Solaris … Every memory allocator claims they are fast, scalable and memory efficient!! But not all allocators can be suited well for our application. Memory hungry application’s performance largely depends on memory allocator performance. In this post, I will only talk about ‘glibc malloc’ memory allocator. In future, I am hoping to cover up other memory allocators. Throughout this post, for better understanding of ‘glibc malloc’, I will link its recent source code. So buckle up, lets get started with glibc malloc!! History: ptmalloc2 was forked from dlmalloc. After fork, threading support was added to it and got released in 2006. After its official release, ptmalloc2 got integrated into glibc source code. Once its integration, code changes were made directly to glibc malloc source code itself. Hence there could be lot of changes between ptmalloc2 and glibc’s malloc implementation. System Calls: As seen in this post malloc internally invokes either brk or mmap syscall. Threading: During early days of linux, dlmalloc was used as the default memory allocator. But later due to ptmalloc2’s threading support, it became the default memory allocator for linux. Threading support helps in improving memory allocator performance and hence application performance. In dlmalloc when two threads call malloc at the same time ONLY one thread can enter the critical section, since freelist data structure is shared among all the available threads. Hence memory allocation takes time in multi threaded applications, resulting in performance degradation. While in ptmalloc2, when two threads call malloc at the same time memory is allocated immediately since each thread maintains a separate heap segment and hence freelist data structures maintaining those heaps are also separate. This act of maintaining separate heap and freelist data structures for each thread is called per thread arena. Example: / Per thread arena example. / /* Per thread arena example. */ #include #include #include #include #include void* threadFunc(void* arg) { printf(\"Before malloc in thread 1\\n\"); getchar(); char* addr = (char*) malloc(1000); printf(\"After malloc and before free in thread 1\\n\"); getchar(); free(addr); printf(\"After free in thread 1\\n\"); getchar(); } int main() { pthread_t t1; void* s; int ret; char* addr; printf(\"Welcome to per thread arena example::%d\\n\",getpid()); printf(\"Before malloc in main thread\\n\"); getchar(); addr = (char*) malloc(1000); printf(\"After malloc and before free in main thread\\n\"); getchar(); free(addr); printf(\"After free in main thread\\n\"); getchar(); ret = pthread_create(&t1, NULL, threadFunc, NULL); if(ret) { printf(\"Thread creation error\\n\"); return -1; } ret = pthread_join(t1, &s); if(ret) { printf(\"Thread join error\\n\"); return -1; } return 0; } Output Analysis: Before malloc in main thread: In the below output we can see that there is NO heap segment yet and no per thread stack too since thread1 is not yet created. "},"glibc/memoryManagement/free.html":{"url":"glibc/memoryManagement/free.html","title":"1.2 free","keywords":"","body":" free "},"chapter2.html":{"url":"chapter2.html","title":"2","keywords":"","body":"chapter 2 "},"chapter3.html":{"url":"chapter3.html","title":"3","keywords":"","body":"chapter 3 "}}