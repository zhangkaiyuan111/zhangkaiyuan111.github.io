{"./":{"url":"./","title":"Introduction","keywords":"","body":"ebook 介绍 软件架构 安装教程 xxxx xxxx xxxx 使用说明 xxxx xxxx xxxx "},"glibc/glibc.html":{"url":"glibc/glibc.html","title":"glibc","keywords":"","body":"glibc官网 "},"glibc/memoryManagement/memoryManagement.html":{"url":"glibc/memoryManagement/memoryManagement.html","title":"1 虚拟地址分配和分页","keywords":"","body":" Memory management 进程内存概念(Process Memory Concepts) GNU 分配器(The GNU Allocator) "},"glibc/memoryManagement/ProcessMemoryConcepts.html":{"url":"glibc/memoryManagement/ProcessMemoryConcepts.html","title":"1.1 进程内存概念","keywords":"","body":" 进程内存概念 进程可用的最基本资源之一是内存。系统组织内存的方式有很多种，但在典型的一种方式中，每个进程都有一个线性虚拟地址空间，地址从零到某个巨大的最大值。它不必是连续的；即，并非所有这些地址实际中都可用于存储数据。 虚拟内存被分成页（典型值为 4 KB）。支持虚拟内存的每一页的是实际内存的一页（称为帧）或一些辅助存储，通常是磁盘空间。磁盘空间可能是交换空间或只是一些普通的磁盘文件。实际上，一个全为零的页有时根本不存在一个标志说它是全零的。 实际内存或后备存储的同一帧可以支持属于多个进程的多个虚拟页。通常是这种情况，例如，GNU C 库代码占用的虚拟内存。包含 printf 函数的同一个实际内存帧支持每个在其程序中调用 printf 的现有进程中的虚拟内存页。 为了让程序访问虚拟页的任何部分，该页此时必须由实际帧支持或连接到实际帧。但是由于虚拟内存通常比实际内存多得多，因此页必须定期在实际内存和后备存储之间来回移动，当进程需要访问它们时进入实际内存，然后在不再需要时退回到后备存储。这种移动称为分页。 当一个程序试图访问一个当时没有实际内存支持的页时，这被称为页错误。当发生页错误时，内核暂停进程，将页放入实际页帧中（这称为“分页（paging in）”或“缺页中断（faulting in）”），然后恢复进程，以便从进程的角度来看，页一直在实际内存中。事实上，对于进程来说，所有页似乎总是在实际内存中。除了一件事：通常为几纳秒的指令的执行时间突然变得非常非常长（因为内核通常必须执行I/O才能完成换页（page-in））。对于对此敏感的程序，锁定页面中描述的功能可以控制它。 在每个虚拟地址空间内，一个进程必须跟踪哪些地址是什么，该进程称为内存分配。分配通常会让人想到分配稀缺资源，但在虚拟内存的情况下，这不是主要目标，因为它通常比任何人需要的要多得多。进程内的内存分配主要只是确保同一字节的内存不用于存储两个不同的东西。 进程以两种主要方式分配内存：通过 exec 和以编程方式。实际上，fork是第三种方式，但不是很有趣。请参阅创建进程。 Exec是为进程创建虚拟地址空间，将其基本程序加载到其中并执行程序的操作。它由“exec”函数族（例如 execl）完成。该操作获取一个程序文件（可执行文件），它分配空间以加载可执行文件中的所有数据，加载它并将控制权转移给它。该数据最值得注意的是程序的指令（文本），还有程序中的文字和常量，甚至一些变量：具有静态存储类的 C 变量（请参阅 C 程序中的内存分配）。 一旦该程序开始执行，它就会使用程序分配来获得额外的内存。在带有 GNU C 库的 C 程序中，有两种程序分配方式：自动分配和动态分配。请参阅 C 程序中的内存分配。 内存映射 I/O 是另一种形式的动态虚拟内存分配。将内存映射到文件意味着声明某个进程地址范围的内容应与指定的常规文件的内容相同。系统使虚拟内存最初包含文件的内容，如果您修改内存，系统会将相同的修改写入文件。请注意，由于虚拟内存和页错误的魔力，在程序访问虚拟内存之前，系统没有理由执行 I/O 来读取文件或为其内容分配实际内存。请参阅内存映射 I/O。 正如它以编程方式分配内存一样，程序可以以编程方式解除分配（释放）它。您无法释放 exec 分配的内存。当程序退出或执行时，你可能会说它的所有内存都被释放了，但是由于在这两种情况下地址空间都不存在了，这一点真的没有实际意义。请参阅程序终止。 "},"glibc/memoryManagement/GNUAllocator.html":{"url":"glibc/memoryManagement/GNUAllocator.html","title":"1.2 GNU 分配器","keywords":"","body":" GNU 分配器 GNU C 库中的 malloc 实现派生自 ptmalloc (pthreads malloc)，而后者又派生自 dlmalloc (由Doug Lea在1987年开发完成，这是Android系统中使用的内存分配器。而Linux系统中采用的是ptmalloc，ptmalloc在dlmalloc的基础上进行了改进，以更好适应多线程)。这个 malloc 可以根据它们的大小和可能由用户控制的某些参数以两种不同的方式分配内存。最常见的方法是从大的连续内存区域分配部分内存（称为块）并管理这些区域以优化它们的使用并减少不可用块形式的浪费。传统上，系统堆被设置为一个大内存区域，但 GNU C 库 malloc 实现维护多个这样的区域以优化它们在多线程应用程序中的使用。每个这样的区域在内部被称为一个arena。 与其他版本相反，GNU C 库中的 malloc 不会将块大小四舍五入为 2 的幂，无论是大的还是小的大小。相邻的块可以在空闲时合并，无论它们的大小是多少。这使得该实现适用于各种分配模式，而通常不会因碎片而导致大量内存浪费。多个 arena 的存在允许多个线程同时在单独的 arena 中分配内存，从而提高性能。 内存分配的另一种方式是非常大的块，即比页大得多。这些请求使用 mmap 分配（匿名或通过 /dev/zero；请参阅内存映射 I/O）。这具有很大的优势，即这些块在被释放时会立即返回到系统。因此，不会发生大块被“锁定”在较小块之间的情况，即使在调用 free 之后也会浪费内存。要使用的 mmap 的大小阈值是动态的，并根据程序的分配模式进行调整。mallopt 可用于使用 M_MMAP_THRESHOLD 静态调整阈值，并且可以使用 M_MMAP_MAX 完全禁用 mmap 的使用；请参阅 Malloc 可调参数。 GNU 分配器的更详细的技术描述保存在 GNU C 库 wiki 中。请参阅wiki。 可以使用您自己的自定义 malloc 代替 GNU C 库提供的内置分配器。请参阅替换 malloc。 基本内存分配（malloc） 要分配一块内存，请调用 malloc。此函数的原型位于 stdlib.h 中。 函数：void * malloc (size t size) 此函数返回一个指向新分配的块 size 字节长的指针，如果无法分配块，则返回一个空指针（设置 errno）。 块的内容是未定义的；您必须自己初始化它（或使用 calloc 代替；请参阅分配已清除空间）。 您可以将 malloc 的结果存储到任何指针变量中而无需强制转换，因为 ISO C 在必要时会自动将类型 void * 转换为另一种类型的指针。但是，如果需要类型但上下文未指定类型，则强制类型转换是必要的。请记住，在为字符串分配空间时，malloc 的参数必须是字符串长度加一。这是因为字符串以不计入字符串“长度”但需要空间的空字符终止。 请记住，在为字符串分配空间时，malloc 的参数必须是字符串长度加一。这是因为字符串以不计入字符串“长度”但需要空间的空字符终止。 malloc 为您提供的块保证是对齐的，以便它可以保存任何类型的数据。在 GNU 系统上，地址在 32 位系统上始终是 8 的倍数，在 64 位系统上始终是 16 的倍数。很少需要任何更高的边界（例如页面边界）；对于这些情况，请使用 aligned_alloc 或 posix_memalign（请参阅分配对齐的内存块）。释放malloc分配的内存（free） 当您不再需要使用 malloc 获得的块时，请使用 free 函数使该块可再次分配。此函数的原型位于 stdlib.h 中 函数：void free (void *ptr) 有时，free 实际上可以将内存返回给操作系统，并使进程更小。通常，它所能做的就是允许稍后调用 malloc 来重用空间。同时，该空间作为 malloc 内部使用的空闲列表的一部分保留在您的程序中。 在程序结束时释放块没有意义，因为当进程终止时，程序的所有空间都归还给系统。 更改块的大小（realloc） 您可以通过调用 realloc 或 reallocarray 使块更长。这些函数在 stdlib.h 中声明。 函数：void realloc (void ptr, size t newsize) realloc 函数将地址为 ptr 的块的大小更改为 newsize。由于块末尾之后的空间可能正在使用中，realloc 可能会发现有必要将块复制到有更多可用空间的新地址。realloc 的返回值是块的新地址。如果需要移动块，realloc 会复制旧的内容。 如果你为 ptr 传递一个空指针，realloc 的行为就像’malloc (newsize)'。否则，如果 newsize 为零，realloc 释放块并返回 NULL。否则，如果 realloc 无法重新分配请求的大小，则返回 NULL 并设置 errno；原始块不受干扰。 函数：void reallocarray (void ptr, size t nmemb, size t size) reallocarray 函数将地址为 ptr 的块的大小更改为足够长以包含 nmemb 元素的向量（vector），每个元素的大小为size。它等效于“realloc (ptr, nmemb * size)”，但如果乘法溢出，reallocarray 会安全失败，方法是将 errno 设置为 ENOMEM，返回一个空指针，并保持原始块不变。 当分配块的新大小是可能溢出的乘法结果时，应使用 reallocarray 而不是 realloc。 与 malloc 一样，如果没有可用的内存空间使块变大，realloc 和 reallocarray 可能会返回空指针。发生这种情况时，原始块保持不变；它没有被修改或搬移。 您还可以使用 realloc 或 reallocarray 使块更小。这样做的原因是为了避免在只需要一点内存空间时占用大量内存空间。在几种分配实现中，有时需要复制一个块，因此如果没有其他可用空间，它可能会失败。 分配已清理空间（calloc） 函数 calloc 分配内存并将其清除为零。它在 stdlib.h 中声明。 函数：void * calloc (size t count, size t eltsize) 此函数分配一个足够长的块以包含 count 元素的向量，每个元素的大小为 eltsize。在 calloc 返回之前，它的内容被清零。 分配对齐的内存块（aligned_alloc） 在 GNU 系统中 malloc 或 realloc 返回的块的地址始终是 8 的倍数（或 64 位系统上的 16）。如果您需要一个地址是 2 的高次幂的倍数的块，请使用aligned_alloc或posix_memalign。aligned_alloc 和 posix_memalign 在 stdlib.h 中声明。 函数：void * aligned_alloc (size t alignment, size t size) aligned_alloc 函数分配一个size字节的块，其地址是alignment的倍数。alignment必须是 2 的幂，size必须是alignment的倍数。aligned_alloc 函数在出错时返回一个空指针，并将 errno 设置为下列值之一： ENOMEM 没有足够的内存来满足请求。 EINVAL alignment不是 2 的幂。 参考 glibc手册03：虚拟地址分配和分页 "},"chapter2.html":{"url":"chapter2.html","title":"2","keywords":"","body":"chapter 2 "},"chapter3.html":{"url":"chapter3.html","title":"3","keywords":"","body":"chapter 3 "}}